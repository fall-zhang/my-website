<!doctype html>
<html lang="zh-CN" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-面试-自检/Vue面试题" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">Vue面试题 | Fall 的笔记本</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://fall-zhang.github.io/my-website/docs/面试-自检/Vue面试题"><meta data-rh="true" name="docusaurus_locale" content="zh-CN"><meta data-rh="true" name="docsearch:language" content="zh-CN"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Vue面试题 | Fall 的笔记本"><meta data-rh="true" name="description" content="Vue三要素"><meta data-rh="true" property="og:description" content="Vue三要素"><link data-rh="true" rel="icon" href="/my-website/./img/favicon.ico"><link data-rh="true" rel="canonical" href="https://fall-zhang.github.io/my-website/docs/面试-自检/Vue面试题"><link data-rh="true" rel="alternate" href="https://fall-zhang.github.io/my-website/docs/面试-自检/Vue面试题" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://fall-zhang.github.io/my-website/docs/面试-自检/Vue面试题" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/my-website/blog/rss.xml" title="Fall 的笔记本 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/my-website/blog/atom.xml" title="Fall 的笔记本 Atom Feed"><link rel="stylesheet" href="/my-website/assets/css/styles.6cc54446.css">
<link rel="preload" href="/my-website/assets/js/runtime~main.81d456e9.js" as="script">
<link rel="preload" href="/my-website/assets/js/main.572a1fc6.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_jwCO" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top navbarHideable_duDI"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/my-website/"><div class="navbar__logo"><img src="/my-website/./img/logo.svg" alt="My Site Logo" class="themedImage_AzXg themedImage--light_gz6F"><img src="/my-website/./img/logo.svg" alt="My Site Logo" class="themedImage_AzXg themedImage--dark_wbl_"></div><b class="navbar__title text--truncate">Fall 的笔记本</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/my-website/docs/">笔记</a><a class="navbar__item navbar__link" href="/my-website/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/Fall-zhang" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_GnfQ"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_drBT colorModeToggle_O6q4"><button class="clean-btn toggleButton_OBl4 toggleButtonDisabled_ne8F" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_eZza"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_Lxcj"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_mA0p"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_l8Aj docsWrapper_KAb6"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_WskB" type="button"></button><div class="docPage_kvSd"><aside class="theme-doc-sidebar-container docSidebarContainer_qwQk"><div class="sidebarViewport_uxQu"><div class="sidebar_uk_I sidebarWithHideableNavbar_roY8"><a tabindex="-1" class="sidebarLogo_B87G" href="/my-website/"><img src="/my-website/./img/logo.svg" alt="My Site Logo" class="themedImage_AzXg themedImage--light_gz6F"><img src="/my-website/./img/logo.svg" alt="My Site Logo" class="themedImage_AzXg themedImage--dark_wbl_"><b>Fall 的笔记本</b></a><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_l1ou"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/my-website/docs/">README</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/my-website/docs/category/javascript--typescript">JavaScript &amp; TypeScript</a><button aria-label="打开/收起侧边栏菜单「JavaScript &amp; TypeScript」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/my-website/docs/category/大前端知识点">大前端知识点</a><button aria-label="打开/收起侧边栏菜单「大前端知识点」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/my-website/docs/HTML和CSS/-- BFC规范">HTML和CSS</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/my-website/docs/Linux &amp; 操作系统/1.1-linux">Linux &amp; 操作系统</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/my-website/docs/React/-- Hooks">React</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/my-website/docs/Vue/-- Vite FAQ">Vue</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/my-website/docs/git工具">git工具</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/my-website/docs/npm 包/axios">npm 包</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/my-website/docs/npm 和 nvm 的使用">npm 和 nvm 的使用</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/my-website/docs/其它语言/java/-- IDEA 的使用">其它语言</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/my-website/docs/前端环境搭建">前端环境搭建</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/my-website/docs/后端/4.2-双向通信">后端</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/my-website/docs/学习资料">学习资料</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/my-website/docs/数据库/-- linux环境下的使用">数据库</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/my-website/docs/跨平台开发/1.1-移动端适配">跨平台开发</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/my-website/docs/软件工程知识/DevOps">软件工程知识</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/my-website/docs/面试-自检/-- HTML、CSS知识点">面试-自检</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试-自检/-- HTML、CSS知识点">-- HTML、CSS知识点</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试-自检/-- JS知识点">-- JS知识点</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试-自检/-- node 知识点">-- node 知识点</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试-自检/-- npm 包相关知识">-- npm 包相关知识</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试-自检/-- 前端知识点">-- 前端知识点</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试-自检/--- 前端知识点自检清单">--- 前端知识点自检清单</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试-自检/1-选择面试题">1-选择面试题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试-自检/2-读代码">2-读代码</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试-自检/3-算法题">3-算法题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/my-website/docs/面试-自检/Vue面试题">Vue面试题</a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_Ia8V"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_YAfL"><div class="docItemContainer_UzBo"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_D4_C" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/my-website/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_SGKc"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">面试-自检</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Vue面试题</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_S2ie theme-doc-toc-mobile tocMobile_yUD8"><button type="button" class="clean-btn tocCollapsibleButton_NQ7N">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Vue面试题</h1></header><h3 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="vue三要素">Vue三要素<a href="#vue三要素" class="hash-link" aria-label="Vue三要素的直接链接" title="Vue三要素的直接链接">​</a></h3><ul><li>响应式：如何监听到数据变化</li><li>模板引擎：如何解析模板</li><li>渲染原理：如何将监听到的数据变化和解析后的HTML渲染</li></ul><p><strong>响应式</strong>：vue2 使用的是<code>Object.defineProperty</code> ，vue3使用的是 Proxy</p><p><strong>模板引擎</strong>：使用正则进行解析，解析成 JS 代码，然后使用</p><p><strong>渲染原理</strong>：</p><h3 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="简单">简单<a href="#简单" class="hash-link" aria-label="简单的直接链接" title="简单的直接链接">​</a></h3><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="vue-组件通讯方式有哪些方法">vue 组件通讯方式有哪些方法<a href="#vue-组件通讯方式有哪些方法" class="hash-link" aria-label="vue 组件通讯方式有哪些方法的直接链接" title="vue 组件通讯方式有哪些方法的直接链接">​</a></h4><ul><li>props 和$emit 父组件向子组件传递数据是通过 prop 传递的，子组件传递数据给父组件是通过$emit 触发事件来做到的</li><li>$parent,$children 获取当前组件的父组件和当前组件的子组件</li><li>$attrs 和$listeners A-&gt;B-&gt;C。Vue 2.4 开始提供了$attrs 和$listeners 来解决这个问题</li><li>父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用)</li><li>$refs 获取组件实例</li><li>envetBus 兄弟组件数据传递 这种情况下可以使用事件总线的方式</li><li>vuex 状态管理</li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="15-vue-响应式原理">15 Vue 响应式原理<a href="#15-vue-响应式原理" class="hash-link" aria-label="15 Vue 响应式原理的直接链接" title="15 Vue 响应式原理的直接链接">​</a></h4><p>整体思路是数据劫持+观察者模式</p><p>对象内部通过 defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存放他所依赖的 watcher（依赖收集），当属性变化后会通知自己对应的 watcher 去更新(派发更新)。</p><p>相关代码如下</p><div class="language-javascript codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-javascript codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">class</span><span class="token plain"> </span><span class="token class-name">Observer</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// 观测值</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token function" style="color:#d73a49">constructor</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">value</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">this</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">walk</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">value</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token function" style="color:#d73a49">walk</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">data</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 对象上的所有属性依次进行观测</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> keys </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token known-class-name class-name">Object</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">keys</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">data</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword control-flow" style="color:#00009f">for</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> keys</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">length</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i</span><span class="token operator" style="color:#393A34">++</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> key </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> keys</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> value </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> data</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">key</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token function" style="color:#d73a49">defineReactive</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">data</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> key</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> value</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// Object.defineProperty数据劫持核心 兼容性在ie9以及以上</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">defineReactive</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">data</span><span class="token parameter punctuation" style="color:#393A34">,</span><span class="token parameter"> key</span><span class="token parameter punctuation" style="color:#393A34">,</span><span class="token parameter"> value</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token function" style="color:#d73a49">observe</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">value</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 递归关键</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// --如果value还是一个对象会继续走一遍odefineReactive 层层遍历一直到value不是对象才停止</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">//   思考？如果Vue数据嵌套层级过深 &gt;&gt;性能会受影响</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token known-class-name class-name">Object</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">defineProperty</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">data</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> key</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">get</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token console class-name">console</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">log</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;获取值&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token comment" style="color:#999988;font-style:italic">//需要做依赖收集过程 这里代码没写出来</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token keyword control-flow" style="color:#00009f">return</span><span class="token plain"> value</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">set</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">newValue</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token keyword control-flow" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">newValue </span><span class="token operator" style="color:#393A34">===</span><span class="token plain"> value</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token keyword control-flow" style="color:#00009f">return</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token console class-name">console</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">log</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;设置值&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token comment" style="color:#999988;font-style:italic">//需要做派发更新过程 这里代码没写出来</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      value </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> newValue</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword module" style="color:#00009f">export</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">observe</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">value</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// 如果传过来的是对象或者数组 进行属性劫持</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword control-flow" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token class-name">Object</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">prototype</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">toString</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">call</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">value</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">===</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;[object Object]&quot;</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">||</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token known-class-name class-name">Array</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">isArray</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">value</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword control-flow" style="color:#00009f">return</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">new</span><span class="token plain"> </span><span class="token class-name">Observer</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">value</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">复制代码</span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>响应式数据原理详解 <a href="https://juejin.cn/post/6935344605424517128" target="_blank" rel="noopener noreferrer">传送门</a></p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="16-vue-nexttick-原理">16 Vue nextTick 原理<a href="#16-vue-nexttick-原理" class="hash-link" aria-label="16 Vue nextTick 原理的直接链接" title="16 Vue nextTick 原理的直接链接">​</a></h4><p>nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法</p><p>相关代码如下</p><div class="language-javascript codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-javascript codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> callbacks </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> pending </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">false</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">flushCallbacks</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  pending </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">false</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//把标志还原为false</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// 依次执行回调</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword control-flow" style="color:#00009f">for</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> callbacks</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">length</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i</span><span class="token operator" style="color:#393A34">++</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    callbacks</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> timerFunc</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//定义异步方法  采用优雅降级</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword control-flow" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">typeof</span><span class="token plain"> </span><span class="token known-class-name class-name">Promise</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">!==</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;undefined&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// 如果支持promise</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> p </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token known-class-name class-name">Promise</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">resolve</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token function-variable function" style="color:#d73a49">timerFunc</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token arrow operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">then</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">flushCallbacks</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> </span><span class="token keyword control-flow" style="color:#00009f">else</span><span class="token plain"> </span><span class="token keyword control-flow" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">typeof</span><span class="token plain"> </span><span class="token maybe-class-name">MutationObserver</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">!==</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;undefined&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// MutationObserver 主要是监听dom变化 也是一个异步方法</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> counter </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> observer </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">new</span><span class="token plain"> </span><span class="token class-name">MutationObserver</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">flushCallbacks</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> textNode </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token dom variable" style="color:#36acaa">document</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">createTextNode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token known-class-name class-name">String</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">counter</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  observer</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">observe</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">textNode</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token literal-property property" style="color:#36acaa">characterData</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">true</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token function-variable function" style="color:#d73a49">timerFunc</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token arrow operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    counter </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">counter </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">%</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">2</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    textNode</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">data</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token known-class-name class-name">String</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">counter</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> </span><span class="token keyword control-flow" style="color:#00009f">else</span><span class="token plain"> </span><span class="token keyword control-flow" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">typeof</span><span class="token plain"> setImmediate </span><span class="token operator" style="color:#393A34">!==</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;undefined&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// 如果前面都不支持 判断setImmediate</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token function-variable function" style="color:#d73a49">timerFunc</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token arrow operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">setImmediate</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">flushCallbacks</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> </span><span class="token keyword control-flow" style="color:#00009f">else</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// 最后降级采用setTimeout</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token function-variable function" style="color:#d73a49">timerFunc</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token arrow operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">setTimeout</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">flushCallbacks</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword module" style="color:#00009f">export</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">nextTick</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">cb</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// 除了渲染watcher  还有用户自己手动调用的nextTick 一起被收集到数组</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  callbacks</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">push</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">cb</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword control-flow" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token operator" style="color:#393A34">!</span><span class="token plain">pending</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 如果多次调用nextTick  只会执行一次异步 等异步队列清空之后再把标志变为false</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pending </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">true</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">timerFunc</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">复制代码</span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>nextTick 原理详解 <a href="https://juejin.cn/post/6939704519668432910#heading-4" target="_blank" rel="noopener noreferrer">传送门</a></p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="17-vue-diff-原理">17 Vue diff 原理<a href="#17-vue-diff-原理" class="hash-link" aria-label="17 Vue diff 原理的直接链接" title="17 Vue diff 原理的直接链接">​</a></h4><p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e3c68d1b0884d9ca0f8ffc5ee64a28e~tplv-k3u1fbpfcp-watermark.image" alt="diff算法.png" class="img_SN3T"></p><p>建议直接看 diff 算法详解 <a href="https://juejin.cn/post/6953433215218483236" target="_blank" rel="noopener noreferrer">传送门</a></p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="1-mvc-和-mvvm-区别">1 MVC 和 MVVM 区别<a href="#1-mvc-和-mvvm-区别" class="hash-link" aria-label="1 MVC 和 MVVM 区别的直接链接" title="1 MVC 和 MVVM 区别的直接链接">​</a></h4><h5 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="mvc">MVC<a href="#mvc" class="hash-link" aria-label="MVC的直接链接" title="MVC的直接链接">​</a></h5><p>MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范</p><ul><li>Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据</li><li>View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的</li><li>Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据</li></ul><img loading="lazy" src="https://filescdn.proginn.com/8d0163ed29f2ed3be88558271f2db16e/8c2f2df56c0b575539f3f5ba37ebecb9.webp" alt="img" style="zoom:80%" class="img_SN3T"><p>MVC 的思想：一句话描述就是 Controller 负责将 Model 的数据用 View 显示出来，换句话说就是在 Controller 里面把 Model 的数据赋值给 View。</p><h5 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="mvvm">MVVM<a href="#mvvm" class="hash-link" aria-label="MVVM的直接链接" title="MVVM的直接链接">​</a></h5><p>MVVM 新增了 VM 类</p><ul><li>ViewModel 层：做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</li></ul><p><img loading="lazy" src="https://filescdn.proginn.com/08efd2b341653b42fd006390554e400c/a5b5d809e339c21cd63b46d616b1fdd4.webp" alt="img" class="img_SN3T">mvvm.png</p><p>MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）</p><p>整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性</p><blockquote><p>注意：Vue 并没有完全遵循 MVVM 的思想 这一点官网自己也有说明</p></blockquote><p><img loading="lazy" src="https://filescdn.proginn.com/e38685d2cf50d13bb7f2175316172e7f/3fcec4773be5f9e71ce7a559c711e896.webp" alt="img" class="img_SN3T">vue-mvvm.png</p><p>那么问题来了 为什么官方要说 Vue 没有完全遵循 MVVM 思想呢？</p><blockquote><p>严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 提供了$refs 这个属性，让 Model 可以直接操作 View，违反了这一规定，所以说 Vue 没有完全遵循 MVVM。</p></blockquote><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="2-为什么-data-是一个函数">2 为什么 data 是一个函数<a href="#2-为什么-data-是一个函数" class="hash-link" aria-label="2 为什么 data 是一个函数的直接链接" title="2 为什么 data 是一个函数的直接链接">​</a></h4><p>组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的  data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份  data，就会造成一个变了全都会变的结果</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="3-vue-组件通讯有哪几种方式">3 Vue 组件通讯有哪几种方式<a href="#3-vue-组件通讯有哪几种方式" class="hash-link" aria-label="3 Vue 组件通讯有哪几种方式的直接链接" title="3 Vue 组件通讯有哪几种方式的直接链接">​</a></h4><ol><li>props 和</li></ol><p>父组件向子组件传递数据是通过</p><p>传递的，子组件传递数据给父组件是通过emit 触发事件来做到的</p><p>children 获取当前组件的父组件和当前组件的子组件</p><p>和listeners A-&gt;B-&gt;C。Vue 2.4 开始提供了</p><ol><li>和listeners 来解决这个问题</li><li>父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用)</li><li>$refs 获取组件实例</li><li>envetBus 兄弟组件数据传递 这种情况下可以使用事件总线的方式</li><li>vuex 状态管理</li></ol><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="4-vue-的生命周期方法有哪些-一般在哪一步发请求">4 Vue 的生命周期方法有哪些 一般在哪一步发请求<a href="#4-vue-的生命周期方法有哪些-一般在哪一步发请求" class="hash-link" aria-label="4 Vue 的生命周期方法有哪些 一般在哪一步发请求的直接链接" title="4 Vue 的生命周期方法有哪些 一般在哪一步发请求的直接链接">​</a></h4><p><strong>beforeCreate</strong> 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问</p><p><strong>created</strong> 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有</p><p>如果非要想与进行交互，可以通过</p><p>nextTick 来访问 Dom</p><p><strong>beforeMount</strong> 在挂载开始之前被调用：相关的 render 函数首次被调用。</p><p><strong>mounted</strong> 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点</p><p><strong>beforeUpdate</strong> 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程</p><p><strong>updated</strong> 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用。</p><p><strong>beforeDestroy</strong> 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除计时器。</p><p><strong>destroyed</strong> Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p><p><strong>activated</strong> keep-alive 专属，组件被激活时调用</p><p><strong>deactivated</strong> keep-alive 专属，组件被销毁时调用</p><blockquote><p>异步请求在哪一步发起？</p></blockquote><p>可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p><p>如果异步请求不需要依赖 Dom 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><ul><li>能更快获取到服务端数据，减少页面 loading 时间；</li><li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="5-v-if-和-v-show-的区别">5 v-if 和 v-show 的区别<a href="#5-v-if-和-v-show-的区别" class="hash-link" aria-label="5 v-if 和 v-show 的区别的直接链接" title="5 v-if 和 v-show 的区别的直接链接">​</a></h4><p>v-if 在编译过程中会被转化成三元表达式,条件不满足时不渲染此节点。</p><p>v-show 会被编译成指令，条件不满足时控制样式将对应节点隐藏 （display:none）</p><p><strong>使用场景</strong></p><p>v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景</p><p>v-show 适用于需要非常频繁切换条件的场景</p><blockquote><p>扩展补充：display:none、visibility:hidden 和 opacity:0 之间的区别？</p></blockquote><p><img loading="lazy" src="https://filescdn.proginn.com/552defe3f9cad1eda94b01a3b6d83330/f371dacd6c752603c5db775a2d76baa8.webp" alt="img" class="img_SN3T">display.png</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="6-说说-vue-内置指令">6 说说 vue 内置指令<a href="#6-说说-vue-内置指令" class="hash-link" aria-label="6 说说 vue 内置指令的直接链接" title="6 说说 vue 内置指令的直接链接">​</a></h4><p><img loading="lazy" src="https://filescdn.proginn.com/a7fd3e772879ef745a58214fe05500c2/ad4e9043c24fce5cd66bd5ad4b0e52d3.webp" alt="img" class="img_SN3T">内置指令.png</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="7-怎样理解-vue-的单向数据流">7 怎样理解 Vue 的单向数据流<a href="#7-怎样理解-vue-的单向数据流" class="hash-link" aria-label="7 怎样理解 Vue 的单向数据流的直接链接" title="7 怎样理解 Vue 的单向数据流的直接链接">​</a></h4><p>数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><blockquote><p>注意：在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告</p></blockquote><p>如果实在要改变父组件的 prop 值 可以再 data 里面定义一个变量 并用 prop 的值初始化它 之后用$emit 通知父组件去修改</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="8-computed-和-watch-的区别和运用的场景">8 computed 和 watch 的区别和运用的场景<a href="#8-computed-和-watch-的区别和运用的场景" class="hash-link" aria-label="8 computed 和 watch 的区别和运用的场景的直接链接" title="8 computed 和 watch 的区别和运用的场景的直接链接">​</a></h4><p>computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容，它可以设置 getter 和 setter。</p><p>watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</p><p>计算属性一般用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑</p><p>计算属性原理详解 传送门</p><p>侦听属性原理详解 传送门</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="9-v-if-与-v-for-为什么不建议一起使用">9 v-if 与 v-for 为什么不建议一起使用<a href="#9-v-if-与-v-for-为什么不建议一起使用" class="hash-link" aria-label="9 v-if 与 v-for 为什么不建议一起使用的直接链接" title="9 v-if 与 v-for 为什么不建议一起使用的直接链接">​</a></h4><p>v-for 和 v-if 不要在同一个标签中使用,因为解析时先解析 v-for 再解析 v-if。如果遇到需要同时使用时可以考虑写成计算属性的方式。</p><hr><h3 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="中等">中等<a href="#中等" class="hash-link" aria-label="中等的直接链接" title="中等的直接链接">​</a></h3><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="10-vue20-响应式数据的原理">10 Vue2.0 响应式数据的原理<a href="#10-vue20-响应式数据的原理" class="hash-link" aria-label="10 Vue2.0 响应式数据的原理的直接链接" title="10 Vue2.0 响应式数据的原理的直接链接">​</a></h4><p>整体思路是数据劫持+观察者模式</p><p>对象内部通过 defineReactive 方法，使用 Object.defineProperty  将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的 dep  属性，存放他所依赖的 watcher（依赖收集），当属性变化后会通知自己对应的 watcher 去更新(派发更新)。</p><p>相关代码如下</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">class Observer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 观测值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  constructor(value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.walk(value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  walk(data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 对象上的所有属性依次进行观测</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let keys = Object.keys(data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (let i = 0; i &lt; keys.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      let key = keys[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      let value = data[key];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      defineReactive(data, key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Object.defineProperty数据劫持核心 兼容性在ie9以及以上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function defineReactive(data, key, value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  observe(value); // 递归关键</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // --如果value还是一个对象会继续走一遍odefineReactive 层层遍历一直到value不是对象才停止</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //   思考？如果Vue数据嵌套层级过深 &gt;&gt;性能会受影响</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Object.defineProperty(data, key, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    get() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      console.log(&quot;获取值&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //需要做依赖收集过程 这里代码没写出来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    set(newValue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (newValue === value) return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      console.log(&quot;设置值&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //需要做派发更新过程 这里代码没写出来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      value = newValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">export function observe(value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 如果传过来的是对象或者数组 进行属性劫持</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Object.prototype.toString.call(value) === &quot;[object Object]&quot; ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Array.isArray(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new Observer(value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>响应式数据原理详解 传送门</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="11-vue-如何检测数组变化">11 Vue 如何检测数组变化<a href="#11-vue-如何检测数组变化" class="hash-link" aria-label="11 Vue 如何检测数组变化的直接链接" title="11 Vue 如何检测数组变化的直接链接">​</a></h4><p>数组考虑性能原因没有用 defineProperty 对数组的每一项进行拦截，而是选择对 7 种数组（push,shift,pop,splice,unshift,sort,reverse）方法进行重写(AOP 切片思想)</p><p>所以在 Vue 中修改数组的索引和长度是无法监控到的。需要通过以上 7 种变异方法修改数组才会触发数组对应的 watcher 进行更新</p><p>相关代码如下</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">// src/obserber/array.js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 先保留数组原型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const arrayProto = Array.prototype;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 然后将arrayMethods继承自数组原型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这里是面向切片编程思想（AOP）--不破坏封装的前提下，动态的扩展功能</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">export const arrayMethods = Object.create(arrayProto);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let methodsToPatch = [</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;push&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;pop&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;shift&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;unshift&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;splice&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;reverse&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;sort&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">methodsToPatch.forEach((method) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  arrayMethods[method] = function (...args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //   这里保留原型方法的执行结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const result = arrayProto[method].apply(this, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这句话是关键</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // this代表的就是数据本身 比如数据是{a:[1,2,3]} 那么我们使用a.push(4)  this就是a  ob就是a.__ob__ 这个属性就是上段代码增加的 代表的是该数据已经被响应式观察过了指向Observer实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const ob = this.__ob__;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里的标志就是代表数组有新增操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let inserted;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    switch (method) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      case &quot;push&quot;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      case &quot;unshift&quot;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inserted = args;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      case &quot;splice&quot;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inserted = args.slice(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果有新增的元素 inserted是一个数组 调用Observer实例的observeArray对数组每一项进行观测</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (inserted) ob.observeArray(inserted);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 之后咱们还可以在这里检测到数组改变了之后从而触发视图更新的操作--后续源码会揭晓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}); </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>数组的观测原理详解 传送门</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="12-vue30-用过吗-了解多少">12 vue3.0 用过吗 了解多少<a href="#12-vue30-用过吗-了解多少" class="hash-link" aria-label="12 vue3.0 用过吗 了解多少的直接链接" title="12 vue3.0 用过吗 了解多少的直接链接">​</a></h4><ul><li>响应式原理的改变 Vue3.x 使用 Proxy 取代 Vue2.x 版本的 Object.defineProperty</li><li>组件选项声明方式 Vue3.x 使用 Composition API setup 是 Vue3.x 新增的一个选项， 他是组件内使用 Composition API 的入口。</li><li>模板语法变化 slot 具名插槽语法 自定义指令 v-model 升级</li><li>其它方面的更改 Suspense 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。基于 treeshaking 优化，提供了更多的内置功能。</li></ul><p>Vue3.0 新特性以及使用经验总结 传送门</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="13-vue30-和-20-的响应式原理区别">13 Vue3.0 和 2.0 的响应式原理区别<a href="#13-vue30-和-20-的响应式原理区别" class="hash-link" aria-label="13 Vue3.0 和 2.0 的响应式原理区别的直接链接" title="13 Vue3.0 和 2.0 的响应式原理区别的直接链接">​</a></h4><p>Vue3.x 改用 Proxy 替代 Object.defineProperty。因为 Proxy 可以直接监听对象和数组的变化，并且有多达 13 种拦截方法。</p><p>相关代码如下</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">import { mutableHandlers } from &quot;./baseHandlers&quot;; // 代理相关逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import { isObject } from &quot;./util&quot;; // 工具方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">export function reactive(target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 根据不同参数创建不同响应式对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return createReactiveObject(target, mutableHandlers);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function createReactiveObject(target, baseHandler) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!isObject(target)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return target;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const observed = new Proxy(target, baseHandler);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return observed;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const get = createGetter();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const set = createSetter();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function createGetter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return function get(target, key, receiver) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 对获取的值进行放射</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const res = Reflect.get(target, key, receiver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&quot;属性获取&quot;, key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (isObject(res)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 如果获取的值是对象类型，则返回当前对象的代理对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return reactive(res);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function createSetter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return function set(target, key, value, receiver) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const oldValue = target[key];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const hadKey = hasOwn(target, key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const result = Reflect.set(target, key, value, receiver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!hadKey) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      console.log(&quot;属性新增&quot;, key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (hasChanged(value, oldValue)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      console.log(&quot;属性值被修改&quot;, key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">export const mutableHandlers = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  get, // 当获取属性时调用此方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  set, // 当修改属性时调用此方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}; </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="14-vue-的父子组件生命周期钩子函数执行顺序">14 Vue 的父子组件生命周期钩子函数执行顺序<a href="#14-vue-的父子组件生命周期钩子函数执行顺序" class="hash-link" aria-label="14 Vue 的父子组件生命周期钩子函数执行顺序的直接链接" title="14 Vue 的父子组件生命周期钩子函数执行顺序的直接链接">​</a></h4><ul><li>加载渲染过程</li></ul><p>父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount-&gt;子 mounted-&gt;父 mounted</p><ul><li>子组件更新过程</li></ul><p>父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p><ul><li>父组件更新过程</li></ul><p>父 beforeUpdate-&gt;父 updated</p><ul><li>销毁过程</li></ul><p>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="15-虚拟-dom-是什么-有什么优缺点">15 虚拟 DOM 是什么 有什么优缺点<a href="#15-虚拟-dom-是什么-有什么优缺点" class="hash-link" aria-label="15 虚拟 DOM 是什么 有什么优缺点的直接链接" title="15 虚拟 DOM 是什么 有什么优缺点的直接链接">​</a></h4><p>由于在浏览器中操作 DOM 是很昂贵的。频繁的操作 DOM，会产生一定的性能问题。这就是虚拟 Dom 的产生原因。Vue2 的 Virtual DOM  借鉴了开源库 snabbdom 的实现。Virtual DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点，是对真实 DOM  的一层抽象。</p><p><strong>优点：</strong></p><ol><li>保证性能下限：框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM  操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li><li>无需手动操作 DOM：我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li><li>跨平台：虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ol><p><strong>缺点:</strong></p><ol><li>无法进行极致优化：虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li><li>首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。</li></ol><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="16-v-model-原理">16 v-model 原理<a href="#16-v-model-原理" class="hash-link" aria-label="16 v-model 原理的直接链接" title="16 v-model 原理的直接链接">​</a></h4><p>v-model 只是语法糖而已</p><p>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value property 和 input 事件；</li><li>checkbox 和 radio 使用 checked property 和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul><blockquote><p>注意:对于需要使用输入法 (如中文、日文、韩文等) 的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。</p></blockquote><p>在普通标签上</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;input v-model=&quot;sth&quot; /&gt;  //这一行等于下一行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;input v-bind:value=&quot;sth&quot; v-on:input=&quot;sth = $event.target.value&quot; /&gt; </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在组件上</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;currency-input v-model=&quot;price&quot;&gt;&lt;/currentcy-input&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;!--上行代码是下行的语法糖</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;currency-input :value=&quot;price&quot; @input=&quot;price = arguments[0]&quot;&gt;&lt;/currency-input&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;!-- 子组件定义 --&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Vue.component(&#x27;currency-input&#x27;, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> template: `</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;span&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   &lt;input</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ref=&quot;input&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    :value=&quot;value&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   &gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;/span&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> `,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> props: [&#x27;value&#x27;],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}) </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="17-v-for-为什么要加-key">17 v-for 为什么要加 key<a href="#17-v-for-为什么要加-key" class="hash-link" aria-label="17 v-for 为什么要加 key的直接链接" title="17 v-for 为什么要加 key的直接链接">​</a></h4><p>如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p><p><strong>更准确</strong>：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。</p><p><strong>更快速</strong>：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</p><p>相关代码如下</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">// 判断两个vnode的标签和key是否相同 如果相同 就可以认为是同一节点就地复用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function isSameVnode(oldVnode, newVnode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return oldVnode.tag === newVnode.tag &amp;&amp; oldVnode.key === newVnode.key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 根据key来创建老的儿子的index映射表  类似 {&#x27;a&#x27;:0,&#x27;b&#x27;:1} 代表key为&#x27;a&#x27;的节点在第一个位置 key为&#x27;b&#x27;的节点在第二个位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function makeIndexByKey(children) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let map = {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  children.forEach((item, index) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map[item.key] = index;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 生成的映射表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let map = makeIndexByKey(oldCh); </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>diff 算法详解 传送门</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="18-vue-事件绑定原理">18 Vue 事件绑定原理<a href="#18-vue-事件绑定原理" class="hash-link" aria-label="18 Vue 事件绑定原理的直接链接" title="18 Vue 事件绑定原理的直接链接">​</a></h4><p>原生事件绑定是通过 addEventListener 绑定给真实元素的，组件事件绑定是通过 Vue 自定义的$on 实现的。如果要在组件上使用原生事件，需要加.native 修饰符，这样就相当于在父组件中把子组件当做普通 html 标签，然后加上原生事件。</p><p>、emit 是基于发布订阅模式的，维护一个事件中心，on 的时候将事件按名称存在事件中心里，称之为订阅者，然后 emit 将对应的事件进行发布，去执行事件中心里的对应的监听器</p><p>手写发布订阅原理 传送门</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="19-vue-router-路由钩子函数是什么-执行顺序是什么">19 vue-router 路由钩子函数是什么 执行顺序是什么<a href="#19-vue-router-路由钩子函数是什么-执行顺序是什么" class="hash-link" aria-label="19 vue-router 路由钩子函数是什么 执行顺序是什么的直接链接" title="19 vue-router 路由钩子函数是什么 执行顺序是什么的直接链接">​</a></h4><p>路由钩子的执行流程, 钩子函数种类有:全局守卫、路由守卫、组件守卫</p><p><strong>完整的导航解析流程:</strong></p><ol><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="20-vue-router-动态路由是什么-有什么问题">20 vue-router 动态路由是什么 有什么问题<a href="#20-vue-router-动态路由是什么-有什么问题" class="hash-link" aria-label="20 vue-router 动态路由是什么 有什么问题的直接链接" title="20 vue-router 动态路由是什么 有什么问题的直接链接">​</a></h4><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router  的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果：</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">const User = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  template: &quot;&lt;div&gt;User&lt;/div&gt;&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const router = new VueRouter({</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  routes: [</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 动态路径参数 以冒号开头</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    { path: &quot;/user/:id&quot;, component: User },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}); </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>问题:vue-router 组件复用导致路由参数失效怎么办？</p></blockquote><p>解决方法：</p><p>1.通过 watch 监听路由参数再发请求</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">watch: { //通过watch来监听路由变化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &quot;$route&quot;: function(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> this.getData(this.$route.params.xxx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>2.用 :key 来阻止“复用”</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;router-view :key=&quot;$route.fullPath&quot; /&gt; </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="21-谈一下对-vuex-的个人理解">21 谈一下对 vuex 的个人理解<a href="#21-谈一下对-vuex-的个人理解" class="hash-link" aria-label="21 谈一下对 vuex 的个人理解的直接链接" title="21 谈一下对 vuex 的个人理解的直接链接">​</a></h4><p>vuex 是专门为 vue 提供的全局状态管理系统，用于多个组件中数据共享、数据缓存等。（无法持久化、内部核心原理是通过创造一个全局实例 new Vue）</p><p><img loading="lazy" src="https://filescdn.proginn.com/2a22391db18f3fc95c87afa0ca822f14/203ef3608bf2265de4d602949bd13f5a.webp" alt="img" class="img_SN3T"> 主要包括以下几个模块：</p><ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="22-vuex-页面刷新数据丢失怎么解决">22 Vuex 页面刷新数据丢失怎么解决<a href="#22-vuex-页面刷新数据丢失怎么解决" class="hash-link" aria-label="22 Vuex 页面刷新数据丢失怎么解决的直接链接" title="22 Vuex 页面刷新数据丢失怎么解决的直接链接">​</a></h4><p>需要做 vuex 数据持久化 一般使用本地存储的方案来保存数据 可以自己设计存储方案 也可以使用第三方插件</p><p>推荐使用 vuex-persist 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="23-vuex-为什么要分模块并且加命名空间">23 Vuex 为什么要分模块并且加命名空间<a href="#23-vuex-为什么要分模块并且加命名空间" class="hash-link" aria-label="23 Vuex 为什么要分模块并且加命名空间的直接链接" title="23 Vuex 为什么要分模块并且加命名空间的直接链接">​</a></h4><p><strong>模块</strong>:由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的  state、mutation、action、getter、甚至是嵌套子模块。</p><p><strong>命名空间</strong>：默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action  作出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true  的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="24-使用过-vue-ssr-吗说说-ssr">24 使用过 Vue SSR 吗？说说 SSR<a href="#24-使用过-vue-ssr-吗说说-ssr" class="hash-link" aria-label="24 使用过 Vue SSR 吗？说说 SSR的直接链接" title="24 使用过 Vue SSR 吗？说说 SSR的直接链接">​</a></h4><p>SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。</p><p><strong>优点：</strong></p><p>SSR 有着更好的 SEO、并且首屏加载速度更快</p><p><strong>缺点：</strong> 开发条件会受到限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。</p><p>服务器会有更大的负载需求</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="25-vue-中使用了哪些设计模式">25 vue 中使用了哪些设计模式<a href="#25-vue-中使用了哪些设计模式" class="hash-link" aria-label="25 vue 中使用了哪些设计模式的直接链接" title="25 vue 中使用了哪些设计模式的直接链接">​</a></h4><p>1.工厂模式 - 传入参数即可创建实例</p><p>虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode</p><p>2.单例模式 - 整个程序有且仅有一个实例</p><p>vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉</p><p>3.发布-订阅模式 (vue 事件机制)</p><p>4.观察者模式 (响应式数据原理)</p><p>5.装饰模式: (@装饰器的用法)</p><p>6.策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略</p><p>...其他模式欢迎补充</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="26-你都做过哪些-vue-的性能优化">26 你都做过哪些 Vue 的性能优化<a href="#26-你都做过哪些-vue-的性能优化" class="hash-link" aria-label="26 你都做过哪些 Vue 的性能优化的直接链接" title="26 你都做过哪些 Vue 的性能优化的直接链接">​</a></h4><blockquote><p>这里只列举针对 Vue 的性能优化 整个项目的性能优化是一个大工程 可以另写一篇性能优化的文章 哈哈</p></blockquote><ul><li>对象层级不要过深，否则性能就会差</li><li>不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）</li><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch 区分使用场景</li><li>v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if</li><li>大数据列表和表格性能优化-虚拟列表/虚拟表格</li><li>防止内部泄漏，组件销毁后把全局变量和事件销毁</li><li>图片懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>适当采用 keep-alive 缓存组件</li><li>防抖、节流运用</li><li>服务端渲染 SSR or 预渲染</li></ul><hr><h3 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="困难">困难<a href="#困难" class="hash-link" aria-label="困难的直接链接" title="困难的直接链接">​</a></h3><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="27-vuemixin-的使用场景和原理">27 Vue.mixin 的使用场景和原理<a href="#27-vuemixin-的使用场景和原理" class="hash-link" aria-label="27 Vue.mixin 的使用场景和原理的直接链接" title="27 Vue.mixin 的使用场景和原理的直接链接">​</a></h4><p>在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立，可以通过 Vue 的 mixin 功能抽离公共的业务逻辑，原理类似“对象的继承”，当组件初始化时会调用 mergeOptions  方法进行合并，采用策略模式针对不同的属性进行合并。当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。</p><p>相关代码如下</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">export default function initMixin(Vue){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Vue.mixin = function (mixin) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //   合并对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.options=mergeOptions(this.options,mixin)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// src/util/index.js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 定义生命周期</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">export const LIFECYCLE_HOOKS = [</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;beforeCreate&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;created&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;beforeMount&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;mounted&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;beforeUpdate&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;updated&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;beforeDestroy&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;destroyed&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 合并策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const strats = {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// mixin核心方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">export function mergeOptions(parent, child) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const options = {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 遍历父亲</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (let k in parent) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mergeFiled(k);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 父亲没有 儿子有</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (let k in child) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!parent.hasOwnProperty(k)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      mergeFiled(k);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //真正合并字段方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  function mergeFiled(k) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (strats[k]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      options[k] = strats[k](parent[k], child[k]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 默认策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      options[k] = child[k] ? child[k] : parent[k];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return options;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Vue.mixin 原理详解 传送门</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="28-nexttick-使用场景和原理">28 nextTick 使用场景和原理<a href="#28-nexttick-使用场景和原理" class="hash-link" aria-label="28 nextTick 使用场景和原理的直接链接" title="28 nextTick 使用场景和原理的直接链接">​</a></h4><p>nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法</p><p>相关代码如下</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">let callbacks = [];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let pending = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function flushCallbacks() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  pending = false; //把标志还原为false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 依次执行回调</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (let i = 0; i &lt; callbacks.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    callbacks[i]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let timerFunc; //定义异步方法  采用优雅降级</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (typeof Promise !== &quot;undefined&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 如果支持promise</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const p = Promise.resolve();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  timerFunc = () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p.then(flushCallbacks);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} else if (typeof MutationObserver !== &quot;undefined&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // MutationObserver 主要是监听dom变化 也是一个异步方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let counter = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const observer = new MutationObserver(flushCallbacks);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const textNode = document.createTextNode(String(counter));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  observer.observe(textNode, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    characterData: true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  timerFunc = () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    counter = (counter + 1) % 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    textNode.data = String(counter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} else if (typeof setImmediate !== &quot;undefined&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 如果前面都不支持 判断setImmediate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  timerFunc = () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    setImmediate(flushCallbacks);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 最后降级采用setTimeout</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  timerFunc = () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    setTimeout(flushCallbacks, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">export function nextTick(cb) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 除了渲染watcher  还有用户自己手动调用的nextTick 一起被收集到数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  callbacks.push(cb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!pending) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果多次调用nextTick  只会执行一次异步 等异步队列清空之后再把标志变为false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pending = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    timerFunc();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>nextTick 原理详解 传送门</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="29-keep-alive-使用场景和原理">29 keep-alive 使用场景和原理<a href="#29-keep-alive-使用场景和原理" class="hash-link" aria-label="29 keep-alive 使用场景和原理的直接链接" title="29 keep-alive 使用场景和原理的直接链接">​</a></h4><p>keep-alive 是 Vue 内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p><ul><li>常用的两个属性 include/exclude，允许组件有条件的进行缓存。</li><li>两个生命周期 activated/deactivated，用来得知当前组件是否处于活跃状态。</li><li>keep-alive 的中还运用了 LRU(最近最少使用) 算法，选择最近最久未使用的组件予以淘汰。</li></ul><p>相关代码如下</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">export default {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  name: &quot;keep-alive&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  abstract: true, //抽象组件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  props: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    include: patternTypes, //要缓存的组件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    exclude: patternTypes, //要排除的组件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    max: [String, Number], //最大缓存数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  created() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.cache = Object.create(null); //缓存对象  {a:vNode,b:vNode}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.keys = []; //缓存组件的key集合 [a,b]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  destroyed() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (const key in this.cache) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      pruneCacheEntry(this.cache, key, this.keys);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  mounted() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //动态监听include  exclude</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.$watch(&quot;include&quot;, (val) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      pruneCache(this, (name) =&gt; matches(val, name));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.$watch(&quot;exclude&quot;, (val) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      pruneCache(this, (name) =&gt; !matches(val, name));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  render() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const slot = this.$slots.default; //获取包裹的插槽默认值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const vnode: VNode = getFirstComponentChild(slot); //获取第一个子组件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const componentOptions: ?VNodeComponentOptions =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      vnode &amp;&amp; vnode.componentOptions;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (componentOptions) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // check pattern</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      const name: ?string = getComponentName(componentOptions);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      const { include, exclude } = this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 不走缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // not included  不包含</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (include &amp;&amp; (!name || !matches(include, name))) ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // excluded  排除里面</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //返回虚拟节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return vnode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      const { cache, keys } = this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      const key: ?string =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vnode.key == null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          ? // same constructor may get registered as different local components</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // so cid alone is not enough (#3269)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            componentOptions.Ctor.cid +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (componentOptions.tag ? `::${componentOptions.tag}` : &quot;&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          : vnode.key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (cache[key]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //通过key 找到缓存 获取实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vnode.componentInstance = cache[key].componentInstance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // make current key freshest</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        remove(keys, key); //通过LRU算法把数组里面的key删掉</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        keys.push(key); //把它放在数组末尾</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cache[key] = vnode; //没找到就换存下来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        keys.push(key); //把它放在数组末尾</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // prune oldest entry  //如果超过最大值就把数组第0项删掉</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          pruneCacheEntry(cache, keys[0], keys, this._vnode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      vnode.data.keepAlive = true; //标记虚拟节点已经被缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 返回虚拟节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return vnode || (slot &amp;&amp; slot[0]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}; </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>扩展补充：LRU 算法是什么？</p></blockquote><p><img loading="lazy" src="https://filescdn.proginn.com/679f9b2736e5f50f01c23bef7c6eac23/57da3650ef83a83c859f186e7c00d5a0.webp" alt="img" class="img_SN3T">lrusuanfa.png</p><p>LRU 的核心思想是如果数据最近被访问过，那么将来被访问的几率也更高，所以我们将命中缓存的组件 key 重新插入到 this.keys  的尾部，这样一来，this.keys 中越往头部的数据即将来被访问几率越低，所以当缓存数量达到最大值时，我们就删除将来被访问几率最低的数据，即  this.keys 中第一个缓存的组件。</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="30-vueset-方法原理">30 Vue.set 方法原理<a href="#30-vueset-方法原理" class="hash-link" aria-label="30 Vue.set 方法原理的直接链接" title="30 Vue.set 方法原理的直接链接">​</a></h4><p>了解 Vue 响应式原理的同学都知道在两种情况下修改数据 Vue 是不会触发视图更新的</p><p>1.在实例创建之后添加新的属性到实例上（给响应式对象新增属性）</p><p>2.直接更改数组下标来修改数组的值</p><p>Vue.set 或者说是$set 原理如下</p><p>因为响应式数据 我们给对象和数组本身都增加了<strong>ob</strong>属性，代表的是 Observer 实例。当给对象新增不存在的属性 首先会把新的属性进行响应式跟踪  然后会触发对象<strong>ob</strong>的 dep 收集到的 watcher 去更新，当修改数组索引时我们调用数组本身的 splice 方法去更新数组</p><p>相关代码如下</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">export function set(target: Array | Object, key: any, val: any): any {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 如果是数组 调用我们重写的splice方法 (这样可以更新视图)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    target.length = Math.max(target.length, key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    target.splice(key, 1, val);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 如果是对象本身的属性，则直接添加即可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (key in target &amp;&amp; !(key in Object.prototype)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    target[key] = val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const ob = (target: any).__ob__;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 如果不是响应式的也不需要将其定义成响应式属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!ob) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    target[key] = val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 将属性定义成响应式的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  defineReactive(ob.value, key, val);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 通知视图更新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ob.dep.notify();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>响应式数据原理详解 传送门</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="31-vueextend-作用和原理">31 Vue.extend 作用和原理<a href="#31-vueextend-作用和原理" class="hash-link" aria-label="31 Vue.extend 作用和原理的直接链接" title="31 Vue.extend 作用和原理的直接链接">​</a></h4><p>官方解释：Vue.extend 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p><p>其实就是一个子类构造器 是 Vue 组件的核心 api 实现思路就是使用原型继承的方法返回了 Vue 的子类 并且利用 mergeOptions 把传入组件的 options 和父类的 options 进行了合并</p><p>相关代码如下</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">export default function initExtend(Vue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let cid = 0; //组件的唯一标识</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 创建子类继承Vue父类 便于属性扩展</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Vue.extend = function (extendOptions) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建子类的构造函数 并且调用初始化方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const Sub = function VueComponent(options) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      this._init(options); //调用Vue初始化方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Sub.cid = cid++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Sub.prototype = Object.create(this.prototype); // 子类原型指向父类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Sub.prototype.constructor = Sub; //constructor指向自己</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Sub.options = mergeOptions(this.options, extendOptions); //合并自己的options和父类的options</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Sub;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Vue 组件原理详解 传送门</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="32-写过自定义指令吗-原理是什么">32 写过自定义指令吗 原理是什么<a href="#32-写过自定义指令吗-原理是什么" class="hash-link" aria-label="32 写过自定义指令吗 原理是什么的直接链接" title="32 写过自定义指令吗 原理是什么的直接链接">​</a></h4><p>指令本质上是装饰器，是 vue 对 HTML 元素的扩展，给 HTML 元素增加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法。</p><p>自定义指令有五个生命周期（也叫钩子函数），分别是 bind、inserted、update、componentUpdated、unbind</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">1. bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4. componentUpdated：被绑定元素所在模板完成一次更新周期时调用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5. unbind：只调用一次，指令与元素解绑时调用。 </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>原理</strong></p><p>1.在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性</p><p>2.通过 genDirectives 生成指令代码</p><p>3.在 patch 前将指令的钩子提取到 cbs 中,在 patch 过程中调用对应的钩子</p><p>4.当执行指令对应钩子函数时，调用对应指令定义的方法</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="33-vue-修饰符有哪些">33 Vue 修饰符有哪些<a href="#33-vue-修饰符有哪些" class="hash-link" aria-label="33 Vue 修饰符有哪些的直接链接" title="33 Vue 修饰符有哪些的直接链接">​</a></h4><p><strong>事件修饰符</strong></p><ul><li>.stop 阻止事件继续传播</li><li>.prevent 阻止标签默认行为</li><li>.capture 使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理</li><li>.self 只当在 event.target 是当前元素自身时触发处理函数</li><li>.once 事件将只会触发一次</li><li>.passive 告诉浏览器你不想阻止事件的默认行为</li></ul><p><strong>v-model 的修饰符</strong></p><ul><li>.lazy 通过这个修饰符，转变为在 change 事件再同步</li><li>.number 自动将用户的输入值转化为数值类型</li><li>.trim 自动过滤用户输入的首尾空格</li></ul><p><strong>键盘事件的修饰符</strong></p><ul><li>.enter</li><li>.tab</li><li>.delete (捕获“删除”和“退格”键)</li><li>.esc</li><li>.space</li><li>.up</li><li>.down</li><li>.left</li><li>.right</li></ul><p><strong>系统修饰键</strong></p><ul><li>.ctrl</li><li>.alt</li><li>.shift</li><li>.meta</li></ul><p><strong>鼠标按钮修饰符</strong></p><ul><li>.left</li><li>.right</li><li>.middle</li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="34-vue-模板编译原理">34 Vue 模板编译原理<a href="#34-vue-模板编译原理" class="hash-link" aria-label="34 Vue 模板编译原理的直接链接" title="34 Vue 模板编译原理的直接链接">​</a></h4><p>Vue 的编译过程就是将 template 转化为 render 函数的过程 分为以下三步</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">第一步是将 模板字符串 转换成 element ASTs（解析器）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">第二步是对 AST 进行静态节点标记，主要用来做虚拟DOM的渲染优化（优化器）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">第三步是 使用 element ASTs 生成 render 函数代码字符串（代码生成器） </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>相关代码如下</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">export function compileToFunctions(template) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 我们需要把html字符串变成render函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 1.把html代码转成ast语法树  ast用来描述代码本身形成树结构 不仅可以描述html 也能描述css以及js语法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 很多库都运用到了ast 比如 webpack babel eslint等等</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let ast = parse(template);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 2.优化静态节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 这个有兴趣的可以去看源码  不影响核心功能就不实现了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //   if (options.optimize !== false) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //     optimize(ast, options);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 3.通过ast 重新生成代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 我们最后生成的代码需要和render函数一样</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 类似_c(&#x27;div&#x27;,{id:&quot;app&quot;},_c(&#x27;div&#x27;,undefined,_v(&quot;hello&quot;+_s(name)),_c(&#x27;span&#x27;,undefined,_v(&quot;world&quot;))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // _c代表创建元素 _v代表创建文本 _s代表文Json.stringify--把对象解析成文本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let code = generate(ast);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //   使用with语法改变作用域为this  之后调用render函数可以使用call改变this 方便code里面的变量取值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let renderFn = new Function(`with(this){return ${code}}`);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return renderFn;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>模板编译原理详解 传送门</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="35-生命周期钩子是如何实现的">35 生命周期钩子是如何实现的<a href="#35-生命周期钩子是如何实现的" class="hash-link" aria-label="35 生命周期钩子是如何实现的的直接链接" title="35 生命周期钩子是如何实现的的直接链接">​</a></h4><p>Vue 的生命周期钩子核心实现是利用发布订阅模式先把用户传入的的生命周期钩子订阅好（内部采用数组的方式存储）然后在创建组件实例的过程中会一次执行对应的钩子方法（发布）</p><p>相关代码如下</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">export function callHook(vm, hook) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 依次执行生命周期对应的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const handlers = vm.$options[hook];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (handlers) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (let i = 0; i &lt; handlers.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      handlers[i].call(vm); //生命周期里面的this指向当前实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 调用的时候</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Vue.prototype._init = function (options) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const vm = this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  vm.$options = mergeOptions(vm.constructor.options, options);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  callHook(vm, &quot;beforeCreate&quot;); //初始化数据之前</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 初始化状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  initState(vm);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  callHook(vm, &quot;created&quot;); //初始化数据之后</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (vm.$options.el) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vm.$mount(vm.$options.el);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}; </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>生命周期实现详解 传送门</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="36-函数式组件使用场景和原理">36 函数式组件使用场景和原理<a href="#36-函数式组件使用场景和原理" class="hash-link" aria-label="36 函数式组件使用场景和原理的直接链接" title="36 函数式组件使用场景和原理的直接链接">​</a></h4><p>函数式组件与普通组件的区别</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">1.函数式组件需要在声明组件是指定 functional:true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.不需要实例化，所以没有this,this通过render函数的第二个参数context来代替</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3.没有生命周期钩子函数，不能使用计算属性，watch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4.不能通过$emit 对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5.因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6.函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop,而普通组件所有未声明的属性都解析到$attrs里面，并自动挂载到组件根元素上面(可以通过inheritAttrs属性禁止) </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>优点 1.由于函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件 2.函数式组件结构比较简单，代码结构更清晰</p><p>使用场景：</p><p>一个简单的展示组件，作为容器组件使用 比如 router-view 就是一个函数式组件</p><p>“高阶组件”——用于接收一个组件作为参数，返回一个被包装过的组件</p><p>相关代码如下</p><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">if (isTrue(Ctor.options.functional)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 带有functional的属性的就是函数式组件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return createFunctionalComponent(Ctor, propsData, data, context, children);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const listeners = data.on;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">data.on = data.nativeOn;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">installComponentHooks(data); // 安装组件相关钩子 （函数式组件没有调用此方法，从而性能高于普通组件） </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="37-能说下-vue-router-中常用的路由模式实现原理吗">37 能说下 vue-router 中常用的路由模式实现原理吗<a href="#37-能说下-vue-router-中常用的路由模式实现原理吗" class="hash-link" aria-label="37 能说下 vue-router 中常用的路由模式实现原理吗的直接链接" title="37 能说下 vue-router 中常用的路由模式实现原理吗的直接链接">​</a></h4><p><strong>hash 模式</strong></p><ol><li>location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</li><li>可以为 hash 的改变添加监听事件</li></ol><div class="codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-text codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token plain">window.addEventListener(&quot;hashchange&quot;, funcRef, false); </span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了</p><blockquote><p>特点：兼容性好但是不美观</p></blockquote><p><strong>history 模式</strong></p><p>利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。</p><p>这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go  的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL  改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。</p><p>特点：虽然美观，但是刷新会出现 404 需要后端进行配置</p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="手写-vueextend-实现">手写 Vue.extend 实现<a href="#手写-vueextend-实现" class="hash-link" aria-label="手写 Vue.extend 实现的直接链接" title="手写 Vue.extend 实现的直接链接">​</a></h4><div class="language-js codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-js codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">//  src/global-api/initExtend.js</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword module" style="color:#00009f">import</span><span class="token plain"> </span><span class="token imports punctuation" style="color:#393A34">{</span><span class="token imports"> mergeOptions </span><span class="token imports punctuation" style="color:#393A34">}</span><span class="token plain"> </span><span class="token keyword module" style="color:#00009f">from</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;../util/index&quot;</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword module" style="color:#00009f">export</span><span class="token plain"> </span><span class="token keyword module" style="color:#00009f">default</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">initExtend</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter maybe-class-name">Vue</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> cid </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//组件的唯一标识</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// 创建子类继承Vue父类 便于属性扩展</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token maybe-class-name">Vue</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method-variable function-variable method function property-access" style="color:#d73a49">extend</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">extendOptions</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 创建子类的构造函数 并且调用初始化方法</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token function-variable function maybe-class-name" style="color:#d73a49">Sub</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function maybe-class-name" style="color:#d73a49">VueComponent</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">options</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token keyword" style="color:#00009f">this</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">_init</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">options</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//调用Vue初始化方法</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token maybe-class-name">Sub</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">cid</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> cid</span><span class="token operator" style="color:#393A34">++</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token class-name">Sub</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">prototype</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token known-class-name class-name">Object</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">create</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">this</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">prototype</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 子类原型指向父类</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token class-name">Sub</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">prototype</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">constructor</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token maybe-class-name">Sub</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//constructor指向自己</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token maybe-class-name">Sub</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">options</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">mergeOptions</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">this</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">options</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> extendOptions</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//合并自己的options和父类的options</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword control-flow" style="color:#00009f">return</span><span class="token plain"> </span><span class="token maybe-class-name">Sub</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">复制代码</span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>具体可以看看这篇 <a href="https://juejin.cn/post/6954173708344770591" target="_blank" rel="noopener noreferrer">手写 Vue2.0 源码（八）-组件原理</a></p><h4 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="vue-router-中路由方法-pushstate-和-replacestate-能否触发-popsate-事件">vue-router 中路由方法 pushState 和 replaceState 能否触发 popSate 事件<a href="#vue-router-中路由方法-pushstate-和-replacestate-能否触发-popsate-事件" class="hash-link" aria-label="vue-router 中路由方法 pushState 和 replaceState 能否触发 popSate 事件的直接链接" title="vue-router 中路由方法 pushState 和 replaceState 能否触发 popSate 事件的直接链接">​</a></h4><p>答案是：<strong>不能</strong></p><p>pushState 和 replaceState</p><p>HTML5 新接口，可以改变网址(存在跨域限制)而不刷新页面，这个强大的特性后来用到了单页面应用如：vue-router，react-router-dom 中。</p><p>注意:仅改变网址,网页不会真的跳转,也不会获取到新的内容,本质上网页还停留在原页面</p><div class="language-js codeBlockContainer_IW09 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_Wktp"><pre tabindex="0" class="prism-code language-js codeBlock_H6ch thin-scrollbar"><code class="codeBlockLines_j5Bm"><span class="token-line" style="color:#393A34"><span class="token dom variable" style="color:#36acaa">window</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">history</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">pushState</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">state</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> title</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> targetURL</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@状态对象：传给目标路由的信息</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">可为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@页面标题：目前所有浏览器都不支持</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">填空字符串即可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@可选url：目标url，不会检查url是否存在，且不能跨域。如不传该项</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">即给当前url添加data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token dom variable" style="color:#36acaa">window</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">history</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">replaceState</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">state</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> title</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> targetURL</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@类似于pushState</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">但是会直接替换掉当前url</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">而不会在history中留下记录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">复制代码</span><br></span></code></pre><div class="buttonGroup_MKfy"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_t4q_" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_N8gI"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_InYZ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>popstate 事件会在点击后退、前进按钮(或调用 history.back()、history.forward()、history.go()方法)时触发</p><blockquote><p><strong>注意:用 history.pushState()或者 history.replaceState()不会触发 popstate 事件</strong></p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_Lz3K" id="参考文章">参考文章<a href="#参考文章" class="hash-link" aria-label="参考文章的直接链接" title="参考文章的直接链接">​</a></h2><table><thead><tr><th>作者</th><th>链接</th></tr></thead><tbody><tr><td>Big shark@LX</td><td><a href="https://juejin.cn/post/6961222829979697165" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6961222829979697165</a></td></tr></tbody></table></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/my-docs/面试-自检/Vue面试题.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_bGo0" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_OqbP"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/my-website/docs/面试-自检/3-算法题"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">3-算法题</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_ZqNy thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#vue三要素" class="table-of-contents__link toc-highlight">Vue三要素</a></li><li><a href="#简单" class="table-of-contents__link toc-highlight">简单</a></li><li><a href="#中等" class="table-of-contents__link toc-highlight">中等</a></li><li><a href="#困难" class="table-of-contents__link toc-highlight">困难</a></li><li><a href="#参考文章" class="table-of-contents__link toc-highlight">参考文章</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://juejin.cn/user/1565342280463325" target="_blank" rel="noopener noreferrer" class="footer__link-item">掘金<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_GnfQ"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/Fall-zhang" target="_blank" rel="noopener noreferrer" class="footer__link-item">Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_GnfQ"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://segmentfault.com/u/fall_zhang0" target="_blank" rel="noopener noreferrer" class="footer__link-item">思否segmentfault<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_GnfQ"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">联系</div><ul class="footer__items clean-list"><li class="footer__item"><a href="#" class="footer__link-item">微信号：mymicrowings</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_GnfQ"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Fall. Built with Docusaurus.</div></div></div></footer></div>
<script src="/my-website/assets/js/runtime~main.81d456e9.js"></script>
<script src="/my-website/assets/js/main.572a1fc6.js"></script>
</body>
</html>