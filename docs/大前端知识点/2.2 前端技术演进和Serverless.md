---
sidebar_position: 12
---

> Create by **fall** on 2021-07-13
> Recently revised in 2021-10-15

## 前端开发模式的演进

| 发展阶段                | 技术栈                 |
| ----------------------- | ---------------------- |
| 基于模板渲染的动态页面  | PHP、JAVA、Html/css/js |
| 基于ajax的前后端分离    | AJAX、jQuery、Extjs    |
| 基于node.js的前端工程化 | Angular、React、VUE    |
| 基于node的全栈开发      |                        |
| Serverless云开发        |                        |

### 基于模板渲染的动态页面

> 最开始的互联网时代，网页简单，就是一些动态或者静态的页面，使用PHP，JAVA写一些动态模板，通过Web Server(`nginx`、apache)将模板解析成一个个HTML文件，此时**还没有前后端分工**，通常是后端工程师顺便写了前端的代码

### 基于ajax的前后端分离

> 2005年，AJAX技术正式提出，而基于ajax可以把web分为前端和后端，前端负责界面和交互，后端负责业务逻辑的处理，通过接口进行数据交互。并且再也**不必在后端语言里书写难以维护的HTML**
>
> 网页的复杂度也由后端的Web Server转向浏览器端的JavaScript，也正因为如此，开始有了前端的岗位

### 基于Node.js的前端工程化

> 2009年node.js出现，与此同时，出现`CommonJS`规范和`npm`包管理机制.之后也出现了`grunt`和`gulp`，`webpack`等基于node.js的前端开发构建工具。
>
> 2013年前后，web前段三大框架(Vue.js,Angular,React.js)相继发布第一个版本，由原来的基于页面的开发转变为基于组件的开发，开发完成后使用Web Pack进行打包构建，从此前端**开发变得规范化，工程化**

### 基于Node.js的全栈开发

> 前端可以是用自己最熟悉的语言Node.js写服务器代码，于是前端开始使用Node.js进行开发，**开始由前端向全栈的方向转变**。
>
> 在Node.js诞生的年代，后端逐渐由巨石应用模式向微服务架构进行转变，随着微服务架构的兴起，后端接口逐渐变得原子性，微服务的接口不在直接面向页面，前端的调用逐渐变得复杂了，然后出现了BFF(Backend for Frontend)，在微服务和前端中间，加了一个BFF层，由于BFF对接口进行聚合、裁剪后，再输出给前端。而BFF不是后端的本质工作，所以交给Node.js进行实现。
>
> **巨石应用**：大部分web工程是将所有的功能模块(service side)打包到一起，并放在一个web容器中运行，很多企业的Java应用程序打包为war包
>
> **微服务架构**：
>
> 一种架构理念，将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持，把一个大型的单体应用和服务拆分为数个或数十个的微小型服务，它可以扩展单个组件而不是整个应用的应用程序堆栈，从而满足服务等级协议。

## `Serverless`

每一次前端开发模式的变化都是某个变革性的技术而起，下一代前端开发模式毫无疑问是`Serverless`

### 什么是`Serverless`

> 从技术角度来说，`Serverless`就是`FaaS`(Function as a Server)和`BaaS`(Backend as a Service)的结合。
>
> `Serverless`的主要特点有：
>
> - 事件驱动，函数在`FaaS`平台中，需要一系列的事件驱动函数来执行。
> - 无状态，每次函数执行，可能是用的都是不同的容器，无法尽兴内存或数据的共享，如果要共享数据，只能通过第三方服务，比如`Redis`
> - 无运维，使用`Serverless`不需要担心服务器，也不需要担心运维，也是`Serverless`的核心
> - 低成本，只需要为每次的函数运行付费，函数不运行则不花钱，不会过度浪费服务器资源。
>
> `Redis`(Remote Dictionary Server)：远程字典服务，可基于内存，也可以持久化的日志型，Key-Value[数据库]

### 常见的服务商解决方案

> 函数云计算：阿里，AWS Lambda，Azure Function
>
> 都支持四个语言：Node.js、Java、C#、Python

> 以往的后端应用被拆分为一个个函数，只需要写完函数并部署到` Serverless `服务即可，后续也不用关心任何服务器的运维操作。后端开发的门槛大幅度降低了。因此，只需要一个前端就可以完成所有的开发工作。
>
> 当然，前端基于`Serverless`去写后端，最好也需要具备一定的后端知识。涉及复杂的后端系统或者`Serverless`不适用的场景，还是需要后端开发。

### 基于`Serverless`的前端开发模式

> **传统开发模式**
>
> 我们需要前端写页面，后端工程师写接口。后端写完接口之后，把接口部署了，再进行前后端联调。联调完毕后再测试、上线。上线之后，还需要运维工程师对系统进行维护。整个过程涉及多个不同角色，链路较长，沟通协调也是一个问题
>
> 设计->服务端开发->服务端部署->前后端联调->测试->上线->运维
>
> **基于`Serverless`的开发模式**
>
> 后端应用被拆分为一个个函数，只要写完函数部署到Serverless服务器即可，也不必担心服务器的运维操作，后端开发门槛降低，因此只需要一个前端就可以完成所有工作。
>
> 设计->应用开发->测试->上线

> **Serverless带来的价值**
>
> - 降低运营复杂度，无须提前规划服务器数量和规格，无需再持续监控和维护服务器的状态，只需要关心应用的主体状态。
> - 降低运营成本，运营的复杂度下降，运营所需投入的人力物力大大降低
> - 缩短产品的上市时间，功能与功能的边际清晰，耦合度大大减小，使得开发效率高，开发周期小

### BFF架构

> 传统BFF
>
> - 一方面，对不同设备需要使用不同的API，由于微服务导致前端接口调用的复杂，所以前段开始使用BFF的方式，对接口进行局和裁剪，以得到适用于前端的接口
> - 最底层的就是各种后端的微服务，最上层的就是各种前端应用。
>
> 传统BFF的痛点
>
> - 前端针对每个设备开发BFF应用，会面临重复开发问题，之前，前端只需要开发页面，现在却需要维护BFF应用，运维成本非常高。
>
> `Serverless` 的 BFF 架构
>
> 用`Serverless`，我们可以用一个个函数来实各个接口的聚合裁剪。前端向 BFF 发起的请求，就相当于是 `FaaS` 的一个 HTTP 触发器，触发一个函数的执行，这个函数中来实现针对该请求的业务逻辑，比如调用多个微服务获取数据，然后再将处理结果返回给前端。这样运维的压力，就由以往的 BFF Server 转向了` FaaS` 服务，前端再也不用关心服务器了。

### 服务端渲染

> **传统服务端渲染**
>
> 渲染方式大部分是客户端渲染，页面初始化的时候，只加载一个简单HTML以及对应的JS文件，再由JS来渲染一个个页面。主要问题是白坪石剑和搜索引擎优化。
>
> 为了解决这些问题，又开始尝试了新的渲染方案，和最早的模板渲染一样，前端发起一个请求，后端 Server 解析出一个 HTML 文档，然后再返回给浏览器。只不过以往是 JSP、PHP 等服务端语言的模板。
>
> 现在是基于 React、Vue 等实现的同构应用，这也是如今的服务端渲染方案的优势。
>
> **基于Serverless的服务器渲染**
>
> 传统渲染每个请求的path都对应着服务端的每个路由，由路由实现对应path的HTML文档渲染，用于渲染服务端程序，就是这些集成了路由应用。
>
> 使用Serverless就是将以往的每个路由拆分为一个个函数，再在FaaS上部署对应的函数，通过这种方式，就讲运维操作转移到了FaaS平台，前端做服务器渲染，就不用再关心服务端的运维部署了
>
> **基于Serverless的小程序开发**
>
> 后端基于云开发，就只需要让开发者关注于业务的实现，由一个前端就能够完成整个应用的前后端开发。

> Docker是一个平台，它主要是提供一些服务，任何一台装有docker的机器你都可以建立、发布、运行你的应用程序，使用docker很省钱省时。

