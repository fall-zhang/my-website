---
sidebar_position: 22
---

> Create by **fall** on 2022-05-19
> Recently revised in 2022-05-20

## 内存

三个主要的 Node 内存消耗区域：

- 代码 - 代码被执行的地方
- 调用栈（译者注：也通常被称为**栈内存**） - 函数和基础数据类型的局部变量，像 number，string，或者 boolean
- 堆内存

现在，在堆上分配一些内存

```js
// 模拟字节数的分配
function allocateMemory(size) {
  const numbers = size / 8;
  const arr = [];
  arr.length = numbers;
  for (let i = 0; i < numbers; i++) {
    arr[i] = i;
  }
  return arr;
}
const memoryLeakAllocations = [];
const field = "heapUsed";
const allocationStep = 10000 * 1024; // 10MB
const TIME_INTERVAL_IN_MSEC = 40;
setInterval(() => {
  const allocation = allocateMemory(allocationStep);
  memoryLeakAllocations.push(allocation);
  const mu = process.memoryUsage(); // process.memoryUsage 是一个收集堆利用率指标的原生工具。
  // # bytes / KB / MB / GB
  const gbNow = mu[field] / 1024 / 1024 / 1024;
  const gbRounded = Math.round(gbNow * 100) / 100;
  console.log(`Heap allocated ${gbRounded} GB`);
}, TIME_INTERVAL_IN_MSEC);

```

通过该方法实现每隔 40 毫秒分配 10 MB 左右内存，这给垃圾回收足够的时间，将存活的对象晋升到老生代中。

在一台内存为 32GB 的搭载 Windows 10 操作系统的笔记本电脑上，垃圾回收器在放弃并抛出“内存栈溢出”异常之前，会尝试压缩内存作为最后手段。这个进程用了 26.6s 达到了 4.1GB 的内存限制，此时它意识到是时候终止了。V8 垃圾回收器一开始运行在具有严格内存限制的 32 位的浏览器进程中。这些结果暗示内存限制也许来自遗留代码。

理论上，64 位进程应该能分配高于 4GB 的内存，并且很容易地扩展到 16TB 的地址空间。

## 参考文章

| 作者       | 链接                                       |
| ---------- | ------------------------------------------ |
| CarlosChen | https://juejin.cn/post/7087578623393136670 |

