> Create by **fall** on 2022-01-30
> Recently revised in 2022-02-03

## 系统重构

> 软件开发成本 = 开发成本 + 维护成本；软件维护成本 = 软件理解成本 + 修改成本 + 测试成本 + 部署成本。 ——Kent Beck

更新、迁移、重构、重写、重搭。

重写，规范代码，更新技术栈。

技术债管理由于重构。

### 为什么重构

重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整期结构。

从这些定义来看，就是之前的系统特性（bug）也要保持该特性，然后让代码可读性变强。

> 重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。。——《重构：改善既有代码的设计》

重构就是为了钱，如果不能带来潜在的价值，就不要谈重构。

### 重构的动机

- 改善既有代码设计
- 帮助找到软件中的 bug（注意，不是修复，而是把出问题的代码找到）
- 提升开发效率
- 提高编程的趣味性——或许。

### 重构不一定带来

> 重构的投入与回报并非呈现线性关系。——《领域驱动设计：软件核心复杂性对应之道》
>
> 毕竟味道越重的代码，相同的重构结果，也会提升更高。

人们总倾向于认为能够带来：更少的代码；更稳定的系统，等等。。。

但是一般来讲，重构是这样的：

- 我们拆分一个上帝类的时候，我们可能拆出了三四个类，因为那些 Import 、package、 type 的 declaration， 反而带来了更多的代码。
- 当我们发现重复代码，并且它们是可以被抽象的，那么我们就可以消去一般的代码。
- 如果我们在重构的过程中，发现 bug，那么系统必然会更加稳定。
- 如果因为我们重构，导致憋人合并代码时发生冲突，反而会带来 bug。
- ......

尽管我们可能不会受益于所有重构的好处，但依然可以带来

- **编程的技艺**。稳定的业务代码，便容易选择合理的识别设计模式。
- **重构的手法**。
- **持续重构的意识**
- **模式和原则**。相似问题的处理使用相似的手法。
- **抽象能力**。

### 大规模重构

在接手别人或者别的新系统的代码，此时进行大规模重构。我们往往不被允许重构，并且如果业务人员说要重构的时候，系统可能不是重构那么简单，也许需要重写。

## 系统重构模式与原则

重构的基本原则

- 小步前进。走一小步，提交一次代码，方便回滚。
- 随时可用。如果不能保证随时可用，那就说不上是重构了。（我理解的为，你重构一个功能后，能够继续使用）
- 融入日常。

PDCA（Plan、Do、Check、Act）做出计划，实施计划，检查效果，纳入标准。不成功的作为下一轮去处理。作者在最前面加了个 E，evaluate（评估，识别需要重构的地方）

### 四级重构

- 架构重构。在不改变业务逻辑的情况下，根据单依职责和依赖倒置原则的思想：对系统进行模块拆分和合并，以明确职责，降低耦合度；对包进行重规划，划分包之间的便捷，减少代码的耦合。（用以明确不同业务包的作用）
- 模型重构。在包含测试的情况下，通过识别和发现模型的行为，将行为聚合到模型中：根基方法名，参数，返回判定内聚到模型中；从流程梳理是否符合业务场景。
- 模式重构。对于特定代码坏味道产生的问题。通过结合架构模式、设计模式来提升可读性。如使用工厂模式统一管理对象的创建；使用策略模式降低复杂度。
- 代码重构。对于一些小的代码坏味道，可以通过 IDE 重构来快速改善既有代码，而不会影响到业务功能。复杂条件语句的提取，使用参数对象冲狗狗参数过多。

> 小步前进：每隔几十行代码（同一个逻辑），随时提交，以及同步代码，方便回滚

### 人员评估

- 确保有足够的能力
- 确保对于重构有共同的看法
- 确保彼此能配合工作

并且具备以下技能：

- 理解面向对象设计
- 了解设计模式
- 了解测试的重要性
- 了解为什么要重构
- 追求代码质量

### 重构范围

对于庞大的系统来说，每一部分的价值并非相等。

对于系统的核心，为它分配最好的开发人员，对于支撑部分来说，分配少量核心开发人员，确保工作能够按时完成。

按照 DDD 的思想来看，就是核心域，支撑域，通用域的区别。

## 重构评估与度量

### 技术债务

> 对于技术债，利息表现在系统的不稳定性，以及由于临时性手段和缺乏合适的设计、文档工作和测试带来的不断攀升的维护成本。—— 《软件架构师应该知道的 97 件事》

不可见（可维护性，可演进性两个方面）：

- 架构：
  - 架构坏味道
  - 反模式
  - 复杂的结构
- 代码：
  - 内部质量低下
  - 代码复杂
  - 代码花味道
  - 违反编程风格
- 其他开发制品：
  - 测试和文档的问题

可见问题：

- 可演进性：
  - 新功能（新增功能）
- 可维护性：
  - bug（缺陷）
  - 外部质量低下

借助 Tequila 架构可视化工具，可以得到项目的调用关系图，某种层面上反映出系统的架构

- 项目的结构划分是否合理
- 项目中的代码是否存在循环依赖的情况

> 如何找到技术债务的位置？
>
> 收集代码坏味道，`coca bs`。
>
> Todo 一般 todo表示应该去做的事，但是没有立刻去做，这些事可能就是项目中的技术债务。

### 重构准入条件

- 工具准备
- 重构看板
- 版本控制
- 自动化构建工具
- 持续集成环境
- 记录
- 探索性重构：可行方案
- 准备知识：坏味道模式

> 重构：改善既有代码的设计中提出的23种代码坏味道
>
> - 代码臃肿。过长函数，过大的类，基本类型偏执，过长参数列，数据泥团
> - 滥用面向对象。Switch 声明，临时字段，被拒绝的遗赠，异曲同工的类
> - 变革的障碍。发散式变化，散弹式修改，平行继承体系。
> - 非必要的。冗余类，纯稚的数据类型，重复代码，注释，没有使用的未来特性。
> - 耦合。不完美的类库，依恋情节，消息链，中间人

> C4模型：System、Container、Component、Code 四个层次，由顶部到底部介绍系统的架构。

### 探索模式

**从分层架构到具体代码**

- 代码库关系
- 代码库内模块化结构
- 模块化包的结构
- 包内代码结构

**从外部适配器到内部适配器**

- 是否包含单元测试
- 是否包含集成测试
- 测试覆盖率情况
- 测试编写情况

**最复杂的情形和最简单的情形**

- 从最简单的场景出发，对常规流程，包间关系有一定的了解
- 从复杂的场景收尾，看最复杂的场景下会有什么问题
- 根据需要寻找一个适合的场景。

### 寻找高引用和修改

识别高修改的文件，用来查看文件的修改次数，如果是上帝类经常进行修改，说明文件经常出现问题。重构着重考虑。

## 系统架构重构

### 防护网

重构不影响 API 的使用方，我们需要设计合适的防护策略。

**检视测试**（表明测试中的问题，测试代码坏味道）

- 空的测试。测试是生成的，但是没有内容。
- 忽略的测试。测试被 ignore
- 没有断言的测试。为了提高测试覆盖率而出现的测试。
- 多余的 PrintIn。调试时留下的信息。
- 多重断言，每个测试函数只应该测试一个概念。

> 架构将大问题分解为容易处理的小问题。——《架构师修炼之道 》

### 重量级重构

**重量级**重构，意味着重构时需要有：

- 积极专注的团队参与
- 复杂的场景
- 领域专家的协助
- 迭代式的模型设计

为此，之前需要进行

- 事件风暴
- 识别上下文，梳理上下文关系
- 划分问题子域
- 识别弹性边界
- 领域建模
- 分层架构

实现时，需要：

- 重搭架构
- 编写集成测试
- 搬移代码

### 轻量级重构

- 结合工具识别出所有的接口
- 通过接口识别出领域名词（聚合、实体）
- 分析接口设计是否合理
- 通过领域名词划分上下文边界
- 重新定义领域名词
- 结合领域名词划分新的 API
- 划分领域和分层架构
- 重新划分分层架构
- 重构 service 代码，剥离领域逻辑
- 重构代码到领域模型

### 限界上下文要素

- 实体（entity）。只要一个对象在生命周期中能够保持连续性，并且独立于它的属性（即：使这些属性对系统用户非常重要），那它就是一个实体。具有唯一标识和生命周期。
- 值对象（value object）。当你只关心某个对象的属性时，该对象便可作为一个值对象。它是实体的附加业务概念，用来描述实体所包含的业务信息。
- 领域服务（domain service）。封装了没有在模型中自检建模为值对象或实体的领域逻辑概念。职责是使用实现和值对象编排业务逻辑。
- 领域事件（domain event）。他用于表明问题域中发生了一些业务人员关心的事情。在明明领域事件时，我们往往选择动词的过去分词，已明确表达事件的属性，（XXX 已经 YYY）
- 资源库（repository）。公开聚合根在内存中的集合的接口，提供聚合根的检索和持久化需要。
- 工厂（factory）。即在实体或者值对象创建复杂时，可以委托给工厂（模式）进行创建。
- 聚合（aggregate）。一种边界内的领域对象集群，可以将其视为一个单元。可以封装一个到多个实体与值对象，用来维护该边界范围之内的业务完整性。

### 微服务重构

一旦涉及到对微服务进行重构，有很大的可能性要对系统进行 API 的重构设计。我们可能会影响到API的使用方，如果使用方是第三方团队的时候，我们就要考虑一下兼容使用方案。这种兼容方案会影响我们的重构。

微服务是一个生态系统，它需要大量的基础设施进行配合，如部署管道、服务注册与发现，日志和监控，负载均衡。

> 该文章笔者对微服务重构也不精，敬请期待我的下一次更新！

## 服务架构重构

（容器架构重构）

Robert C. Martin 总结了六边形架构（即端口与适配器架构）、DCI  （Data-Context-Interactions，数据-场景-交互）架构、BCI（Boundary Control  Entity，Boundary Control Entity）架构等多种架构，归纳出了这些架构的基本特点：

- 框架无关性。不依赖于框架中的某一个函数，框架只是一个工具，系统不能，不去适应框架。
- 可被测试。业务逻辑脱离于 UI、数据库等外部元素进行测试。
- UI 无关性。不需要修改系统的其它部分，就可以变更 UI，诸如由 Web 界面替换成 CLI。
- 数据库无关性。业务逻辑与数据库之间需要进行解耦，我们可以随意切换LocalStorage、IndexedDB、Web SQL
- 外部机构（agency）无关性。系统的业务逻辑，不需要知道其它外部接口，诸如安全、调度、代理。

-----

 *这段不怎么会*

**实体（Entities）**，实体用于封装企业范围的业务规则。实体可以是拥有方法的对象，也可以是数据结构和函数的集合。如果没有企业，只是单个应用，那么实体就是应用里的业务对象。这些对象封装了最通用和高层的业务规则，极少会受到外部变化的影响。任何操作层面的改动都不会影响到这一层。

**用例（Use Cases）**，用例是特定于应用的业务逻辑，一般用来完成用户的某个操作。用例协调数据流向或者流出实体层，并且在此过程中通过执行实体的业务规则来达成用例的目标。用例层的改动不会影响到内部的实体层，同时也不会受外层的改动影响，比如数据库、UI 和框架的变动。只有而且应当应用的操作发生变化的时候，用例层的代码才随之修改。

**接口适配器（Interface Adapters）**。接口适配器层的主要作用是转换数据，数据从最适合内部用例层和实体层的结构转换成适合外层（比如数据持久化框架）的结构。反之，来自于外部服务的数据也会在这层转换为内层需要的结构。

**框架和驱动（Frameworks and Drivers）**。最外层由各种框架和工具组成，比如 Web 框架、数据库访问工具等。通常在这层不需要写太多代码，大多是一些用来跟内层通信的胶水代码。这一层包含了所有实现细节，把实现细节锁定在这一层能够减少它们的改动对整个系统造成的伤害。

### 真的是util？

往往会向 util 内添加逻辑，正如会忘 common/bean 中扔入所有的 model

| 阶段     | 解释                                           | 示例                                                       |
| -------- | ---------------------------------------------- | ---------------------------------------------------------- |
| 空白     | 没有名称                                       | doSomething()                                              |
| 凑合     | 名称不能准确反应元素的含义                     | preload()                                                  |
| 沾边     | 名称至少反映了元素某一方面的功能               | DomSomethingEvilToDB()                                     |
| 反映功能 | 名称直接描述了元素的所有功能                   | ParseXmlAndStoreFightToDbAndLocalCacheAndStartProcessing() |
| 反映角色 | 名称充分地反映了元素在架构中的角色             | StoreFightlightToDatabaseAndStartProcessing                |
| 反映意图 | 名称不仅反映元素的功能，还能反映其目的。       | BeginTrackingFlight()                                      |
| 领域抽象 | 名称超越了单个元素本身，成为一个新的抽象概念。 | MonitoringPanle.Add(new Flight())                          |















## 参考文章

| 名称     | 链接                   |
| -------- | ---------------------- |
| 系统重构 | https://migration.ink/ |

## 相关链接

| 文章名称             | 链接                                                         |
| -------------------- | ------------------------------------------------------------ |
| 分层架构重构         | https://www.phodal.com/blog/refactor-mvc-architecture-to-ddd/ |
| 构建可信软件系统     | https://www.phodal.com/blog/build-trusted-software-system/   |
| 测试代码的坏味道     | https://www.phodal.com/blog/test-bad-smell/                  |
| 技术债治理的四条原则 | https://insights.thoughtworks.cn/managing-technical-debt/    |

技术债治理的四条原则：

- 核心领域优先
- 可演进性优于可维护性
- 明确清晰地责任定义优于松散无序的任务分配
- 主动预防优于被动响应



