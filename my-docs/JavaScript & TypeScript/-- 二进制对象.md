---
sidebar_position: 7
---

> Create by **fall** on 2020----
> Recently revised in 2022-07-10

# 二进制对象

总共有五个大对象，`Blob`、`ArrayBuffer`、`File`、`FileReader` 和 `FormData`

- `Blob`、`ArrayBuffer`、`File` 可以归为一类，它们都是数据；
- `FileReader` 算是一种工具，用来读取数据；
- `FormData` 可以看做是一个应用数据的场景。

## Blob

`Blob` 全称是 `binary large object`，`Blob` 对象就是一个包含有**只读原始数据**的类文件对象，通俗讲就是**不可修改**的二进制文件。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。

创建 Blob 对象

```js
// let aBlob = new Blob(blobParts,options);
// blobParts：ArrayBufferView + Blob + ArrayBuffer + DOMString 等对象构成的数组，其中 DOMString 会被编译为 utf-8
// options：一个可选对象，包含两个属性
// type：默认为 '' 表明放到 blob 中的数组内容的 MIME 类型（见注释）
// endings：用于指定包含行结束符的 `n` 字符串如何被写入，默认为 "transparent"保持 blob 中的格式不变，可选为 "native"，代表行结束符，会被更改为适合宿主操作系统文件系统的换行符
let myBlob = new Blob(['Fall'],{type:'text/plain'})
```

> MIME：Multipurpose Internet Mail Extensions：多用途互联网邮件扩展类型，用来区分文件的种类。

Blob 对象上的属性

```js
let blobParts = ['<html><h2>Hello Semlinker</h2></html>']; // an array consisting of a single DOMString
let myBlob = new Blob(blobParts, {type : 'text/html'}); // the blob
// 此时 myBlob 是一个对象，拥有 size, type 两个属性
console.log(myBlob.size + " bytes"); // myBlob.size 用字节表示的数据大小（只读）
// 37 bytes
console.log("MIME type is "+myBlob.type); // myBlob.type 表示 MIME 类型（只读）
// MIME type is text/html
```

Blob 上面的方法

```js
// Blob 对象是不可改变的，但是可以通过 slice 进行分割 start：分割起始点 end：分割终点  contentType:新的MIME类型
Blob.prototype.slice(start, end ,contentType)
// 返回一个能读取 Blob 内容的 ReadableStream
Blob.prototype.stream()
// 返回一个 Promise 对象，且包含 blob 所有内容的
Blob.prototyoe.text()
// 转换为 arrayBuffer 异步转换返回一个 Promise 对象
blob.arrayBuffer().then((res) => {
  console.log(res);
});
```

### Blob URL

将一个 `file` 或者 `Blob` 类型的数据转换为 `UTF-16` 的字符串，并保存在当前操作的 `document` 下，并存储在内存中。

```
类似这样一个链接
blob:http://localhost:3000/53acc2b6-f47b-450f-a390-bf0665e04e59
```

```js
// 生成 blob url 
URL.createObjectURL(file/blob)
// 清除方式只有页面 unload() 事件或者使用
// 手动清除
URL.revokeObjectURL(objectURL)
```

前端下载经常会使用这些内容

```js
export const downloadFile = async (params, fileName) => {
  // 我们使用axios设置接口返回类型 responseType: "blob", 所以这里从后端返回的是blob。
  const results = await download(params);
  
  const a = document.createElement("a");
  a.download = fileName + ".xlsx";
  // 生成blob url。这里可以使用Blob对象或者File对象
  a.href = window.URL.createObjectURL(results);
  a.style.display = "none";
  document.body.appendChild(a);
  a.click();
  // 释放内存
  window.URL.revokeObjectURL(a.href);
  document.body.removeChild(a);
};
```



## File

File 对象继承自 Blob，也是二进制对象，通常用在 `<input type='file'>` 选择的 `FileList` 对象。或者是拖拽产生的 `DataTransfer` 对象。

```js
var oneFile = new File(array,name,options)
// array 数据构成的数组
// name 文件名
// options 设置一些属性，Type 属性，lastModified
// File 对象上的属性
oneFile.name// 文件名
oneFile.size// 文件大小
oneFile.lastModified // 最后修改时间的时间戳
oneFile.lastModifiedDate // 最后修改时间的 Date 对象
oneFile.type // MIME类型
```

方法继承自 `Blob`

```js
File.prototype.slice(start, end ,contentType)
File.prototype.stream()
File.prototyoe.text()
File.arrayBuffer().then((res) => {
  console.log(res);
});
```

## FileReader

`FileReader` 可以将 `Blob`、`File` 进行异步读取存储在用户计算机上的文件（或者原始数据缓冲区），读取为不同的格式。

`FileReader` 的使用

```js
// 创建一个 fileReader 对象
const fileReader = new FileReader()
// 属性
fileReader.error // 表示在读取过程中出现错误
fileReader.result // 返回文件的内容，读取完成后，该属性才会生效，result 会根据不同的读取方式有不同的结果
fileReader.readyState // 表示当前文件的读取状态，0：没有加载任何数据，1：数据正在被加载，2：已经完成全部读取请求
```

方法

```js
// 无论读取成功与否，并不会返回读取的结果，结果会被存储在 result 属性中
fileReader.abort() // 终止读取操作，readyState 为 2
fileReader.readAsArrayBuffer() // 将读取的内容转换为 ArrayBuffer
FileReader.readAsBinaryString()
FileReader.readAsDataURL(blob) // 将数据转化为 Base64 的 data url
FileReader.readAsText(blob) // 将二进制数据读取并编码为字符串形式
```

事件

```js
fileReader.onabort // 读取操作中断时触发
fileReader.onerror // 当出现错误时触发
fileReader.onload // 读取操作完成时触发
fileReader.onloadstart // 读取操作开始时触发
fileReader.onloadend // 读取操作结束时触发，成功或者失败
fileReader.onprogress // 处理 progrress 事件，读取 Blob 时触发
```

使用

```js
const blob = new Blob(['hello','everyday'],{type:'text/plain'})
const fileReaderOne = new FileReader()
fileReader.readAsDataURL(blob)
fileReader.onload=()=>{
  console.log(fileReader) // 成功后 fileReader.result 是想要的结果
}
```

## Base64

经常使用的一种编码格式

js 内置了两个方法进行字符串的 `Base64` 编码和解码

```js
const str = 'Fall'
// 编码
const b = window.btoa(str)
b // "RmFsbA==" 
// 解码
const str2 = window.atob(b)
str2 // "Fall" 
```

用途和特性：

- 将较小的图片转为字符串，拼接后进行传输，减少请求次数。
- 对数据进行加密（不安全）
- 编码后体积变大，至少增加 33%，如果过是一个字节，至少变为三个字节
- 编码也需要消耗额外工作量



## ArrayBuffer

内存上的一段二进制数据，它不能直接进行读写，可以通过 `TypeArray`、`DataView` 进行操作。

`Blob` 与 `ArrayBuffer` 的关系

- `ArrayBuffer` 是底层的二进制数据，可以借助工具进行读写。
- `Blob` 可以接受一个 `ArrayBuffer` 作为参数生成的一个 `Blob` 对象，相当于将 `ArrayBuffer` 封装为一个整体。拿到的是一个整体，你能看到大小，类型，但是不能看到细节。

> `Blob` 作为一个整体的文件，适合用于传输。只有关注文件的细节修改一部分的数据，才会用到 `ArrayBuffer`。



## FormData

异步上传二进制文件

## TypedArray 和 DataView

TypedArray：一组构造函数，一共包含九种类型，每一种都是一个构造函数。

### TypedArray

一组构造函数，一共包含九种类型，每一种都是一个构造函数。

`TypedArray` 的构造函数接受三个参数，第一个 `ArrayBuffer`（其实还可以是数组、视图这里不细说）对象，第二个视图开始的字节号（默认0），第三个视图结束的字节号（默认直到本段内存区域结束）。

| 名称              | 占用字节 | 描述                                   |
| ----------------- | -------- | -------------------------------------- |
| Int8Array         | 1        | 8位有符号整数                          |
| Uint8Array        | 1        | 8位无符号整数                          |
| Uint8ClampedArray | 1        | 8位无符号整型固定数组(数值在0~255之间) |
| Int16Array        | 2        | 16位有符号整数                         |
| Uint16Array       | 2        | 16位无符号整数                         |
| Int32Array        | 4        | 32 位有符号整数                        |
| Uint32Array       | 4        | 32 位无符号整数                        |
| Float32Array      | 4        | 32 位 IEEE 浮点数                      |
| Float64Array      | 8        | 64 位 IEEE 浮点数                      |

```js
const buffer =  [ 126, 226 ] // 可以是数组、视图、ArrayBuffer
const uint8 = new Uint8Array(buffer); // 将 ArrayBuffer 中的每个字节视为 0 到 255 之间的单个数字（每个字节是 8 位）。这称为 “8 位无符号整数”。
const uint16 = new Uint16Array(buffer); // 将每 2 个字节视为一个 0 到 65535 之间的整数。这称为 “16 位无符号整数”。
const uint32 = new Uint32Array(buffer);// 将每 4 个字节视为一个 0 到 4294967295 之间的整数。这称为 “32 位无符号整数”。
const float64 = new Float64Array(buffer);//  将每 8 个字节视为一个 5.0x10-324 到 1.8x10308 之间的浮点数。
```

### DataView

更灵活的视图，DataView 视图支持除 Uint8ClampedArray 以外的八种类型。

```js
const dataView1 = new DataView(buffer);
console.log(dataView1);
console.log(dataView1.getUint8(0));
console.log(dataView1.getUint16(0));
console.log(dataView1.getUint32(0));
console.log(dataView1.getFloat64(0));
```

## 互相转换

### Blob 和 File

```js
// file 转换为 Blob
let file = new File(['文件'],'fileName',{type:'text/plain'})
let blob = new Blob([file],{type:file.type})

// Blob 转化为 File
let blob = new Blob(['blob文件',{type:'text/plain'}])
let oneFile = new File([Blob],'fileName',{type:blob.type})
```

### 转为 base64

```js
// File / Blob 转为 base64
function toDataURL(blob,callBack){
  let a = new FileReader()
  a.onload = function (e){callBack(e.target.result)}
  a.readAsDataURL(blob)
}
const blob = new Blob(['hello','fall'],{type:'text/plain'})
const file = new File(['byte','me'],'allright')
toDataURL(blob,(result)=>{
  console.log(result)
})
toDataURL(file,(result)=>{
  console.log(result)
})
```

`img` 转为 `Base64`

```js
const imgToBase64 = (imgURL)=>{
  let image = new Image()
  image.src = imgURL
  return new Promise(resolve=>{
    image.onload=()=>{
      let canvas = document.createElement('canvas')
      canvas.width = image.width
      canvas.height = image.height
      let context = canvas.getContext('2d')
      context.drawImage(image,0,0,image.width,image.height)
      let dataURL = canvas.toDataURL('image/png')
      resolve(dataURL)
    }
  })
}
imgToBase64("../vue2/src/assets/logo.png").then((res) => {
  console.log(res);
});
```

### Base64 转换

转为 Blob

```js
function dataURLtoBlob(dataurl) {
  // `data:[<mediatype>][;base64],<data>`
  var arr = dataurl.split(","),
    mime = arr[0].match(/:(.*?);/)[1],
    bstr = atob(arr[1]),
    n = bstr.length,
    u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new Blob([u8arr], { type: mime });
}

```

转为 File

```js
function dataURLtoFile(dataurl, filename) {
  //将base64转换为文件
  var arr = dataurl.split(","),
    mime = arr[0].match(/:(.*?);/)[1],
    bstr = atob(arr[1]),
    n = bstr.length,
    u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new File([u8arr], filename, { type: mime });
}
```

## 参考文章

| 作者（文章名称） | 连接                                       |
| ---------------- | ------------------------------------------ |
| controZL         | https://juejin.cn/post/6915795898609975309 |
| 阿宝哥           | https://juejin.cn/post/6980142557066067982 |
| 你不知道的 Blob  | http://caibaojian.com/blob.html            |
| 苏苏同学         | https://juejin.cn/post/7046313942938812424 |
|                  |                                            |


