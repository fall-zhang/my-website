---
sidebar_position: 30
---

>Create by **fall** on 2021-09-22
>Recently revised in 2022-01-27

## 文件处理

前端的文件处理包括，上传，类型检查，文件类型转换，二进制处理等

## 二进制文件

`Blob` 全称是 `binary large object`，`Blob` 对象就是一个包含有**只读原始数据**的类文件对象，通俗讲就是**不可修改**的二进制文件。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。

创建 Blob 对象

```js
// let aBlob = new Blob(blobParts,options);
// blobParts：ArrayBufferView + Blob + ArrayBuffer + DOMString 等对象构成的数组，其中 DOMString 会被编译为 utf-8
// options：一个可选对象，包含两个属性
// type：默认为 '' 表明放到 blob 中的数组内容的 MIME 类型（见注释）
// endings：用于指定包含行结束符的 `n` 字符串如何被写入，默认为 "transparent"保持 blob 中的格式不变，可选为 "native"，代表行结束符，会被更改为适合宿主操作系统文件系统的换行符
let myBlob = new Blob(['Fall'],{type:'text/plain'})
```

> MIME：Multipurpose Internet Mail Extensions：多用途互联网邮件扩展类型，用来区分文件的种类。

Blob 对象上的属性

```js
let blobParts = ['<html><h2>Hello Semlinker</h2></html>']; // an array consisting of a single DOMString
let myBlob = new Blob(blobParts, {type : 'text/html'}); // the blob
// 此时 myBlob 是一个对象，拥有 size, type 两个属性
console.log(myBlob.size + " bytes"); // myBlob.size 用字节表示的数据大小（只读）
// 37 bytes
console.log("MIME type is "+myBlob.type); // myBlob.type 表示 MIME 类型（只读）
// MIME type is text/html
```

Blob 上面的方法

```js
// Blob 对象是不可改变的，但是可以通过 slice 进行分割 start：分割起始点 end：分割终点  contentType:新的MIME类型
Blob.prototype.slice(start, end ,contentType)
// 返回一个能读取 Blob 内容的 ReadableStream
Blob.prototype.stream()
// 返回一个 Promise 对象，且包含 blob 所有内容的
Blob.prototyoe.text()
// 转换为 arrayBuffer 异步转换返回一个 Promise 对象
blob.arrayBuffer().then((res) => {
  console.log(res);
});
```

### Blob URL

将一个 `file` 或者 `Blob` 类型的数据转换为 `UTF-16` 的字符串，并保存在当前操作的 `document` 下，并存储在内存中。

```
类似这样一个链接
blob:http://localhost:3000/53acc2b6-f47b-450f-a390-bf0665e04e59
```

```js
// 生成 blob url 
URL.createObjectURL(file/blob)
// 清除方式只有页面 unload() 事件或者使用
// 手动清除
URL.revokeObjectURL(objectURL)
```

前端下载经常会使用这些内容

```js
export const downloadFile = async (params, fileName) => {
  // 我们使用axios设置接口返回类型 responseType: "blob", 所以这里从后端返回的是blob。
  const results = await download(params);
  
  const a = document.createElement("a");
  a.download = fileName + ".xlsx";
  // 生成blob url。这里可以使用Blob对象或者File对象
  a.href = window.URL.createObjectURL(results);
  a.style.display = "none";
  document.body.appendChild(a);
  a.click();
  // 释放内存
  window.URL.revokeObjectURL(a.href);
  document.body.removeChild(a);
};
```

## 上传文件

场景：单文件、多文件、目录上传、压缩目录上传、拖拽上传、剪贴板上传、大文件分块上传、服务端上传。

### 单文件上传

**前端代码**

```html
<input id='uploadFile' type="file" accept="image/*"/>
<button id='submit' onclick='uploadFile()'>上传文件</button>
```

其中 accept 用于限制上传文件类型。IE9 以下不支持该属性

- `image/*` 限制只能上传 image 文件
- `image/png` 限制只能上传png
- `image/png,image/jpeg` 限制只能上传png和jpg

> accept只进行限制后缀名，把后缀名更改还是可以绕过检测，而想实现只接受特定的格式，使用其他工具，或者是看这个教程 [如何区分图片类型](https://juejin.cn/post/6971935704938971173)。

**JS代码**

```js
const uploadFileEle = document.querySelector('#uploadFile')
const request = axios.create({
  baseURL:'http://localhost:8080/upload',
  timeout:60000
})
// 判断是否存在文件，获取文件，进行上传
async functioin uploadFile(){
  if(!uploadFileEle.files.length) return
  const file = uploadFileEle.files[0]
  upload({
    url:'/single',
    file
  })
}
function upload({url,file,fieldName='file'}){
  let formData = new FormData()
  formData.set(fieldName,file)
  request.post(url,formData,{
    onPuloadProgress:function(progressEvent){
      const percentCompleted = Math.round(
      (progressEvent.loaded*100)/progressEvent.total)
    }
    console.log(percentCompleted)
  })
}
```

上述代码先把读取的File对象封装成FormData对象，然后利用Axios的post实现文件上传的功能。再上传之前，通过请求配置对象的onUploadProgress 就可以获取文件的上传进度。

**服务端代码**

Koa框架。实现的服务端代码。

### 分片上传



## 文件类型

对于不同类型的文件，初始的几个字节内容都是固定的。

文件都是三十二位，二进制存储。比如说，`D4` 就是 1 Byte 。

| 文件类型 | 文件后缀 | 魔数                                 |
| -------- | -------- | ------------------------------------ |
| JPEG     | jpg/jpeg | 0xFF D8 FF                           |
| PNG      | png      | 0x89 50 4E 47 0D 0A 1A 0A            |
| GIF      | gif      | 0x47 49 46 38（GIF8）                |
| BMP      | bmp      | 0x42 4D                              |
| PDF      | pdf      | 0x25 50 44 46 对应的字符串为（%PDF） |

问题来了，一个文件，开头是 `89 50 4E 47`，那么它是什么类型文件？查表可知：`png`

```js
function readBuffer(file,start=0,end=2){
  return new Promise((resolve,reject)=>{
    const reader = new FileReader()
    reader.onerror = rejcet
    reader.onload=()=>{
      resolve(reader.result)
    }
    reader.readAsArrayBuffer(file.slice(start,end))
  })
}
```

### 如何检查

```js
function check(headers){
  return (buffers,options={offset:0})=>headers.every((header,index)=>header===buffers[options.offset+index])
}
// 高阶函数，生成对应的函数
// 翻译验证对应的函数
// 比如说，生成检查 PNG 的函数
const isPNG = check([0x98,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a])

```

有一个检查类型的库：`file-type`

> Create by **fall** on 2020----
> Recently revised in 2022-07-10



总共有五个大对象，`Blob`、`ArrayBuffer`、`File`、`FileReader` 和 `FormData`

- `Blob`、`ArrayBuffer`、`File` 可以归为一类，它们都是数据；
- `FileReader` 算是一种工具，用来读取数据；
- `FormData` 可以看做是一个应用数据的场景。



## File

File 对象继承自 Blob，也是二进制对象，通常用在 `<input type='file'>` 选择的 `FileList` 对象。或者是拖拽产生的 `DataTransfer` 对象。

```js
var oneFile = new File(array,name,options)
// array 数据构成的数组
// name 文件名
// options 设置一些属性，Type 属性，lastModified
// File 对象上的属性
oneFile.name// 文件名
oneFile.size// 文件大小
oneFile.lastModified // 最后修改时间的时间戳
oneFile.lastModifiedDate // 最后修改时间的 Date 对象
oneFile.type // MIME类型
```

方法继承自 `Blob`

```js
File.prototype.slice(start, end ,contentType)
File.prototype.stream()
File.prototyoe.text()
File.arrayBuffer().then((res) => {
  console.log(res);
});
```

## FileReader

`FileReader` 可以将 `Blob`、`File` 进行异步读取存储在用户计算机上的文件（或者原始数据缓冲区），读取为不同的格式。

`FileReader` 的使用

```js
// 创建一个 fileReader 对象
const fileReader = new FileReader()
// 属性
fileReader.error // 表示在读取过程中出现错误
fileReader.result // 返回文件的内容，读取完成后，该属性才会生效，result 会根据不同的读取方式有不同的结果
fileReader.readyState // 表示当前文件的读取状态，0：没有加载任何数据，1：数据正在被加载，2：已经完成全部读取请求
```

方法

```js
// 无论读取成功与否，并不会返回读取的结果，结果会被存储在 result 属性中
fileReader.abort() // 终止读取操作，readyState 为 2
fileReader.readAsArrayBuffer() // 将读取的内容转换为 ArrayBuffer
FileReader.readAsBinaryString()
FileReader.readAsDataURL(blob) // 将数据转化为 Base64 的 data url
FileReader.readAsText(blob) // 将二进制数据读取并编码为字符串形式
```

事件

```js
fileReader.onabort // 读取操作中断时触发
fileReader.onerror // 当出现错误时触发
fileReader.onload // 读取操作完成时触发
fileReader.onloadstart // 读取操作开始时触发
fileReader.onloadend // 读取操作结束时触发，成功或者失败
fileReader.onprogress // 处理 progrress 事件，读取 Blob 时触发
```

使用

```js
const blob = new Blob(['hello','everyday'],{type:'text/plain'})
const fileReaderOne = new FileReader()
fileReader.readAsDataURL(blob)
fileReader.onload=()=>{
  console.log(fileReader) // 成功后 fileReader.result 是想要的结果
}
```

## Base64

经常使用的一种编码格式

js 内置了两个方法进行字符串的 `Base64` 编码和解码

```js
const str = 'Fall'
// 编码
const b = window.btoa(str)
b // "RmFsbA==" 
// 解码
const str2 = window.atob(b)
str2 // "Fall" 
```

用途和特性：

- 将较小的图片转为字符串，拼接后进行传输，减少请求次数。
- 对数据进行加密（不安全）
- 编码后体积变大，至少增加 33%，如果过是一个字节，至少变为三个字节
- 编码也需要消耗额外工作量



## ArrayBuffer

内存上的一段二进制数据，它不能直接进行读写，可以通过 `TypeArray`、`DataView` 进行操作。

`Blob` 与 `ArrayBuffer` 的关系

- `ArrayBuffer` 是底层的二进制数据，可以借助工具进行读写。
- `Blob` 可以接受一个 `ArrayBuffer` 作为参数生成的一个 `Blob` 对象，相当于将 `ArrayBuffer` 封装为一个整体。拿到的是一个整体，你能看到大小，类型，但是不能看到细节。

> `Blob` 作为一个整体的文件，适合用于传输。只有关注文件的细节修改一部分的数据，才会用到 `ArrayBuffer`。

## FormData

异步上传二进制文件

## TypedArray 和 DataView

TypedArray：一组构造函数，一共包含九种类型，每一种都是一个构造函数。

### TypedArray

一组构造函数，一共包含九种类型，每一种都是一个构造函数。

`TypedArray` 的构造函数接受三个参数，第一个 `ArrayBuffer`（其实还可以是数组、视图这里不细说）对象，第二个视图开始的字节号（默认0），第三个视图结束的字节号（默认直到本段内存区域结束）。

| 名称              | 占用字节 | 描述                                   |
| ----------------- | -------- | -------------------------------------- |
| Int8Array         | 1        | 8位有符号整数                          |
| Uint8Array        | 1        | 8位无符号整数                          |
| Uint8ClampedArray | 1        | 8位无符号整型固定数组(数值在0~255之间) |
| Int16Array        | 2        | 16位有符号整数                         |
| Uint16Array       | 2        | 16位无符号整数                         |
| Int32Array        | 4        | 32 位有符号整数                        |
| Uint32Array       | 4        | 32 位无符号整数                        |
| Float32Array      | 4        | 32 位 IEEE 浮点数                      |
| Float64Array      | 8        | 64 位 IEEE 浮点数                      |

```js
const buffer =  [ 126, 226 ] // 可以是数组、视图、ArrayBuffer
const uint8 = new Uint8Array(buffer); // 将 ArrayBuffer 中的每个字节视为 0 到 255 之间的单个数字（每个字节是 8 位）。这称为 “8 位无符号整数”。
const uint16 = new Uint16Array(buffer); // 将每 2 个字节视为一个 0 到 65535 之间的整数。这称为 “16 位无符号整数”。
const uint32 = new Uint32Array(buffer);// 将每 4 个字节视为一个 0 到 4294967295 之间的整数。这称为 “32 位无符号整数”。
const float64 = new Float64Array(buffer);//  将每 8 个字节视为一个 5.0x10-324 到 1.8x10308 之间的浮点数。
```

### DataView

更灵活的视图，DataView 视图支持除 Uint8ClampedArray 以外的八种类型。

```js
const dataView1 = new DataView(buffer);
console.log(dataView1);
console.log(dataView1.getUint8(0));
console.log(dataView1.getUint16(0));
console.log(dataView1.getUint32(0));
console.log(dataView1.getFloat64(0));
```

## 互相转换

### Blob 和 File

```js
// file 转换为 Blob
let file = new File(['文件'],'fileName',{type:'text/plain'})
let blob = new Blob([file],{type:file.type})

// Blob 转化为 File
let blob = new Blob(['blob文件',{type:'text/plain'}])
let oneFile = new File([Blob],'fileName',{type:blob.type})
```

### 转为 base64

```js
// File / Blob 转为 base64
function toDataURL(blob,callBack){
  let a = new FileReader()
  a.onload = function (e){callBack(e.target.result)}
  a.readAsDataURL(blob)
}
const blob = new Blob(['hello','fall'],{type:'text/plain'})
const file = new File(['byte','me'],'allright')
toDataURL(blob,(result)=>{
  console.log(result)
})
toDataURL(file,(result)=>{
  console.log(result)
})
```

`img` 转为 `Base64`

```js
const imgToBase64 = (imgURL)=>{
  let image = new Image()
  image.src = imgURL
  return new Promise(resolve=>{
    image.onload=()=>{
      let canvas = document.createElement('canvas')
      canvas.width = image.width
      canvas.height = image.height
      let context = canvas.getContext('2d')
      context.drawImage(image,0,0,image.width,image.height)
      let dataURL = canvas.toDataURL('image/png')
      resolve(dataURL)
    }
  })
}
imgToBase64("../vue2/src/assets/logo.png").then((res) => {
  console.log(res);
});
```

### Base64 转换

转为 Blob

```js
function dataURLtoBlob(dataurl) {
  // `data:[<mediatype>][;base64],<data>`
  var arr = dataurl.split(","),
    mime = arr[0].match(/:(.*?);/)[1],
    bstr = atob(arr[1]),
    n = bstr.length,
    u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new Blob([u8arr], { type: mime });
}

```

转为 File

```js
function dataURLtoFile(dataurl, filename) {
  //将base64转换为文件
  var arr = dataurl.split(","),
    mime = arr[0].match(/:(.*?);/)[1],
    bstr = atob(arr[1]),
    n = bstr.length,
    u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new File([u8arr], filename, { type: mime });
}
```

## 应用场景

### 保存文件

```js
const onSaveFile = () => {
  const blob = new Blob([codeContext.value], { type: 'text/javascript' });
  const url = URL.createObjectURL(blob)
  const a = document.createElement("a");
  a.download = "sunshine";
  a.href = url;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}
```

### 分片上传

分片上传：对于大文件的上传，通过 slice 的方法对大文件进行切割，然后分片进行上传

```js
const file = new File(['a'.repeat(1000000)],'test.txt')
const chunkSize = 40000
const postUrl = 'https://example.web/post'
async function chunkUpload(){
  for(let start = 0;start<file.size;start+=chunkSize){
    const chunk = file.slice(start,start+chunkSize+1)
    const fd = new FormData()
    fd.append('data',chunk)
    await fetch(postUrl,{method:'post',body:fd}).then(res=>{
      res.text()
    })
  }
}
```

### 下载数据

下载数据：可以将从互联网上下载的数据存放到 Blob 对象中

```js
// 使用 XMLHttpRequest
const downloadBlob = (url,callback)=>{
  const xhr = new XMLHttpRequest()
  xhr.open('GET',url)
  xhr.responseType = 'blob'
  xhr.onload=()=>{
    callback(xhr.response)
  }
  xhr.send(null)
}
// 使用 fetch
const myImg = document.querySelector('img')
const myReq = new Request('flowers.jpg')
fetch(myReq).then(res=>{
  return response.blob()
}).then(blob=>{
  let objURL = URL.createObjectURL(blob)
  myImage.src = objURL
})
```

## 参考文章

| 作者（文章名称）                | 连接                                       |
| ------------------------------- | ------------------------------------------ |
| controZL                        | https://juejin.cn/post/6915795898609975309 |
| 阿宝哥                          | https://juejin.cn/post/6980142557066067982 |
| 你不知道的 Blob                 | http://caibaojian.com/blob.html            |
| 苏苏同学                        | https://juejin.cn/post/7046313942938812424 |
| JavaScript 如何检测文件的类型？ | https://juejin.cn/post/6971935704938971173 |

