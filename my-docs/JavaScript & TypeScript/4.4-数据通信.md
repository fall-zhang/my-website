---
sidebar_position: 30
---

>Create by **fall** on 2021-09-22
>Recently revised in 2022-01-27

## 文件处理

前端的文件处理包括，上传，类型检查，文件类型转换，二进制处理，文件下载

## 上传文件

场景：单文件、多文件、目录上传、压缩目录上传、拖拽上传、剪贴板上传、大文件分块上传、服务端上传。

### 单文件上传

**前端代码**

```html
<input id='uploadFile' type="file" accept="image/*"/>
<button id='submit' onclick='uploadFile()'>上传文件</button>
```

其中 accept 用于限制上传文件类型。IE9 以下不支持该属性（IE 已死）

- `image/*` 限制只能上传 image 文件
- `image/png` 限制只能上传png
- `image/png,image/jpeg` 限制只能上传png和jpg

> accept只进行限制后缀名，把后缀名更改还是可以绕过检测，而想实现只接受特定的格式，使用其他工具，或者是看这个教程 [如何区分图片类型](https://juejin.cn/post/6971935704938971173)。

**JS代码**

```js
const uploadFileEle = document.querySelector('#uploadFile')
const request = axios.create({
  baseURL:'http://localhost:8080/upload',
  timeout:60000
})
// 判断是否存在文件，获取文件，进行上传
async functioin uploadFile(){
  if(!uploadFileEle.files.length) return
  const file = uploadFileEle.files[0]
  upload({
    url:'/single',
    file
  })
}
function upload({url,file,fieldName='file'}){
  let formData = new FormData()
  formData.set(fieldName,file)
  request.post(url,formData,{
    onPuloadProgress:function(progressEvent){
      const percentCompleted = Math.round(
      (progressEvent.loaded*100)/progressEvent.total)
    }
    console.log(percentCompleted)
  })
}
```

上述代码先把读取的File对象封装成FormData对象，然后利用Axios的post实现文件上传的功能。再上传之前，通过请求配置对象的onUploadProgress 就可以获取文件的上传进度。

### 分片上传

## 应用场景

### 保存文件

```js
const onSaveFile = () => {
  const blob = new Blob([codeContext.value], { type: 'text/javascript' });
  const url = URL.createObjectURL(blob)
  const a = document.createElement("a");
  a.download = "sunshine";
  a.href = url;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}
```

### 分片上传

分片上传：对于大文件的上传，通过 slice 的方法对大文件进行切割，然后分片进行上传

```js
const file = new File(['a'.repeat(1000000)],'test.txt')
const chunkSize = 40000
const postUrl = 'https://example.web/post'
async function chunkUpload(){
  for(let start = 0;start<file.size;start+=chunkSize){
    const chunk = file.slice(start,start+chunkSize+1)
    const fd = new FormData()
    fd.append('data',chunk)
    await fetch(postUrl,{method:'post',body:fd}).then(res=>{
      res.text()
    })
  }
}
```

### 下载数据

下载数据：可以将从互联网上下载的数据存放到 Blob 对象中

```js
// 使用 XMLHttpRequest
const downloadBlob = (url,callback)=>{
  const xhr = new XMLHttpRequest()
  xhr.open('GET',url)
  xhr.responseType = 'blob'
  xhr.onload=()=>{
    callback(xhr.response)
  }
  xhr.send(null)
}
// 使用 fetch
const myImg = document.querySelector('img')
const myReq = new Request('flowers.jpg')
fetch(myReq).then(res=>{
  return response.blob()
}).then(blob=>{
  let objURL = URL.createObjectURL(blob)
  myImage.src = objURL
})
```

### 导出为 Excel

导入文件：

- 用户上传文件，前端 FileReader 读取文件为二进制字符串
- 解析二进制字符串为 excel 工作簿对象
- XLSX.utils.sheet_to_json()方法，从工作簿对象中获取第一张 Sheets 表格数据并将其转换为 json 数据。

导出文件：

- XLSX.utils.book_new() 创建工作簿对象
- 

需要用到 xlsx 插件

```js
import xlsx from 'xlsx'
export const exportJsonToExcel = ({
  header,
  data,
  key,
  title,
  filename,
  autoWidth
}) => {
  const wb = XLSX.utils.book_new()
  if (header) {
    data.unshift(header)
  }
  if (title) {
    data.unshift(title)
  }
  const ws = XLSX.utils.json_to_sheet(data, {
    header: key,
    skipHeader: true
  })
  if (autoWidth) {
    const arr = json_to_array(key, data)
    auto_width(ws, arr)
  }
  xlsx.utils.book_append_sheet(wb, ws, filename)
  xlsx.writeFile(wb, filename + '.xlsx')
}
```

```js
function importExcel (file, tableTemplate) {
  return new Promise((resolve, reject) => {
    let f = file.raw // 获取文件内容
    // 通过DOM取文件数据
    let rABS = false // 是否将文件读取为二进制字符串
    let reader = new FileReader()
    FileReader.prototype.readAsBinaryString = function (f) {
      let binary = ''
      let rABS = false // 是否将文件读取为二进制字符串
      let wb // 读取完成的数据
      let outdata
      let reader = new FileReader()
      reader.onload = function (e) {
        let bytes = new Uint8Array(reader.result)
        let length = bytes.byteLength
        for (let i = 0; i < length; i++) {
          binary += String.fromCharCode(bytes[i])
        }
        let XLSX = require('xlsx')
        if (rABS) {
          wb = XLSX.read(btoa(binary), { // 手动转化
            type: 'base64'
          })
        } else {
          wb = XLSX.read(binary, {
            type: 'binary'
          })
        }
        outdata = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]) // outdata就是表格中的值
        let arr = []
        // 下面是数据解析提取逻辑
        if (tableTemplate.length > 0) {
          let tempArr = Object.keys(outdata[0])
          let tempArrNew = []
          for (let i in tempArr) {
            for (let k in tableTemplate) {
              if (i === k) {
                tempArrNew.push({fieldE: tableTemplate[k], fieldC: tempArr[i]})
              }
            }
          }

          tempArr = tempArrNew
          outdata.map(item => {
            let obj = {}
            tempArr.map(temp2 => {
              obj[temp2.fieldE] = item[temp2.fieldC]
            })
            arr.push(obj)
          })
        }
        resolve(arr)
      }
      reader.readAsArrayBuffer(f)
    }
    if (rABS) {
      reader.readAsArrayBuffer(f)
    } else {
      reader.readAsBinaryString(f)
    }
  })
}
```



## 参考文章

| 作者（文章名称） | 连接                                                         |
| ---------------- | ------------------------------------------------------------ |
| controZL         | https://juejin.cn/post/6915795898609975309                   |
| 阿宝哥           | https://juejin.cn/post/6980142557066067982                   |
| 阿宝哥           | [JavaScript 如何检测文件的类型？](https://juejin.cn/post/6971935704938971173) |
| 你不知道的 Blob  | http://caibaojian.com/blob.html                              |
| 苏苏同学         | https://juejin.cn/post/7046313942938812424                   |
| 灵扁扁           | [js实现导入导出excel文件](https://juejin.cn/post/7086879982768783391) |

